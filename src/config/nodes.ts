
import type { AvailableNodeType, RetryConfig, BranchConfig, OnErrorWebhookConfig } from '@/types/workflow';
import { Bot, Braces, FileJson, FunctionSquare, GitBranch, HelpCircle, LogOut, Network, Play, Terminal, Workflow as WorkflowIcon, Database, Mail, Clock, Youtube, TrendingUp, DownloadCloud, Scissors, UploadCloud, Filter, Combine, SplitSquareHorizontal, ListOrdered, Milestone, CaseSensitive, GitFork, Layers, Repeat, RotateCcw, VenetianMask, LucideIcon } from 'lucide-react';

export const NODE_WIDTH = 180;
export const NODE_HEIGHT = 90; 

const GENERIC_RETRY_CONFIG_SCHEMA = {
  retry: { 
    label: 'Retry Config (JSON, Optional)', 
    type: 'json', 
    placeholder: '{\n  "attempts": 3,\n  "delayMs": 1000,\n  "backoffFactor": 2,\n  "retryOnStatusCodes": [500, 503, 429],\n  "retryOnErrorKeywords": ["timeout", "unavailable"]\n}',
    helperText: 'Define retry strategy: attempts, delayMs, backoffFactor (e.g., 2 for exponential), retryOnStatusCodes (for HTTP), retryOnErrorKeywords (case-insensitive). All fields optional.',
    defaultValue: {} as RetryConfig
  }
};

const GENERIC_ON_ERROR_WEBHOOK_SCHEMA = {
  onErrorWebhook: {
    label: 'On-Error Webhook (JSON, Optional)',
    type: 'json',
    placeholder: '{\n  "url": "https://my-error-logger.com/log",\n  "method": "POST",\n  "headers": {"X-API-Key": "{{env.ERROR_API_KEY}}"},\n  "bodyTemplate": {\n    "nodeId": "{{failed_node_id}}",\n    "nodeName": "{{failed_node_name}}",\n    "errorMessage": "{{error_message}}",\n    "timestamp": "{{timestamp}}",\n    "workflowDataSnapshot": "{{workflow_data_snapshot_json}}"\n  }\n}',
    helperText: 'If node fails after retries, send details to this webhook. Placeholders for body/headers: {{failed_node_id}}, {{failed_node_name}}, {{error_message}}, {{timestamp}}, {{workflow_data_snapshot_json}} (full workflow data as JSON string), and {{env.VAR}}.',
    defaultValue: undefined as (OnErrorWebhookConfig | undefined)
  }
};

export const AVAILABLE_NODES_CONFIG: AvailableNodeType[] = [
  {
    type: 'trigger',
    name: 'Manual Trigger',
    icon: Play,
    description: 'Manually starts the workflow.',
    category: 'trigger',
    defaultConfig: { event: 'manualStart' },
    configSchema: {
      event: { label: 'Event Type', type: 'string', defaultValue: 'manualStart', placeholder: 'e.g., manual, webhook' },
    },
    outputHandles: ['output'],
  },
  {
    type: 'httpRequest',
    name: 'HTTP Request',
    icon: Network,
    description: 'Makes an HTTP request. Supports retries and on-error webhook.',
    category: 'action', 
    defaultConfig: { url: '', method: 'GET', headers: '{\n  "Authorization": "{{env.MY_API_TOKEN}}"\n}', body: '', retry: {}, onErrorWebhook: undefined },
    configSchema: {
      url: { label: 'URL', type: 'string', placeholder: 'https://api.example.com/data' },
      method: { 
        label: 'Method', 
        type: 'select', 
        options: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
        defaultValue: 'GET',
      },
      headers: { label: 'Headers (JSON)', type: 'textarea', placeholder: '{\n  "Content-Type": "application/json",\n  "Authorization": "Bearer {{env.MY_API_TOKEN}}"\n}', helperText: "Use {{env.VAR_NAME}} for secrets." },
      body: { label: 'Body (JSON/Text)', type: 'textarea', placeholder: '{\n  "key": "value"\n}' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['response', 'status_code', 'error_message', 'status'],
  },
  {
    type: 'schedule',
    name: 'Schedule',
    icon: Clock,
    description: 'Triggers workflow on a defined schedule.',
    category: 'trigger',
    defaultConfig: { cron: '0 * * * *' }, 
    configSchema: {
      cron: { label: 'Cron Expression', type: 'string', defaultValue: '0 * * * *', placeholder: 'e.g., 0 9 * * MON' },
    },
    outputHandles: ['triggered_at'],
  },
  {
    type: 'sendEmail',
    name: 'Send Email',
    icon: Mail,
    description: 'Sends an email. Supports retries and on-error webhook. Configure mail server via EMAIL_ env vars.',
    category: 'action',
    defaultConfig: { to: '', subject: '', body: '', retry: {}, onErrorWebhook: undefined },
    configSchema: {
      to: { label: 'To', type: 'string', placeholder: 'recipient@example.com or {{input.email}}' },
      subject: { label: 'Subject', type: 'string', placeholder: 'Workflow Notification: {{input.status}}' },
      body: { label: 'Body (HTML or Text)', type: 'textarea', placeholder: 'Details: {{input.details}}' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['messageId', 'status', 'error_message'],
  },
  {
    type: 'databaseQuery',
    name: 'Database Query',
    icon: Database,
    description: 'Executes a SQL query. Supports retries and on-error webhook. Configure DB_CONNECTION_STRING env var.',
    category: 'io',
    defaultConfig: { queryText: 'SELECT * FROM my_table WHERE id = $1;', queryParams: '["{{input.id}}"]', retry: {}, onErrorWebhook: undefined },
    configSchema: {
      queryText: { label: 'SQL Query (use $1, $2 for parameters)', type: 'textarea', placeholder: 'SELECT * FROM users WHERE id = $1 AND status = $2;' },
      queryParams: { label: 'Query Parameters (JSON array)', type: 'json', placeholder: '["{{input.userId}}", "active"]', helperText: "Array of values or placeholders for $1, $2, etc." },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'], 
    outputHandles: ['results', 'rowCount', 'status', 'error_message'],
  },
  {
    type: 'parseJson',
    name: 'Parse JSON',
    icon: Braces,
    description: 'Parses a JSON string and extracts data using a path.',
    category: 'logic',
    defaultConfig: { jsonString: '', path: '' },
    configSchema: {
      jsonString: { label: 'JSON Input (e.g. {{prev_node.response}})', type: 'textarea', placeholder: '{{previous_node.response}}' },
      path: { label: 'Extraction Path (e.g. $.data.items[0].name)', type: 'string', placeholder: '$.data.items[0].name' },
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'logMessage',
    name: 'Log Message',
    icon: Terminal,
    description: 'Logs a message to the workflow execution log.',
    category: 'io',
    defaultConfig: { message: 'Workflow log: ' },
    configSchema: {
      message: { label: 'Message to Log', type: 'textarea', placeholder: 'Current value: {{data.value}}' },
    },
    inputHandles: ['input'],
    outputHandles: ['output'],
  },
  {
    type: 'aiTask',
    name: 'AI Task',
    icon: Bot,
    description: 'Performs a task using a GenAI model. Supports retries and on-error webhook.',
    category: 'ai',
    defaultConfig: { prompt: '', model: 'googleai/gemini-1.5-flash-latest', retry: {}, onErrorWebhook: undefined },
    configSchema: {
      prompt: { label: 'Prompt', type: 'textarea', placeholder: 'Summarize the following text: {{input.text}}' },
      model: { label: 'Model ID', type: 'string', defaultValue: 'googleai/gemini-1.5-flash-latest', placeholder: 'e.g., googleai/gemini-1.5-pro-latest' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'conditionalLogic',
    name: 'Condition',
    icon: Filter,
    description: 'Evaluates a condition. Use its boolean `result` in a subsequent node\'s `_flow_run_condition` config field (e.g. {{this_node_id.result}}) to control execution.',
    category: 'logic',
    defaultConfig: { condition: '' },
    configSchema: {
        condition: { label: 'Condition string (e.g., {{data.value}} == "success", {{data.count}} > 10, {{data.isValid}} === true)', type: 'string', placeholder: '{{data.temperature}} > 30' },
    },
    inputHandles: ['input'],
    outputHandles: ['result'],
  },
  {
    type: 'dataTransform',
    name: 'Transform Data',
    icon: FunctionSquare, 
    description: 'Performs various predefined data transformations. Supports retries and on-error webhook for the overall transformation process.',
    category: 'logic',
    defaultConfig: { 
      transformType: 'toUpperCase', 
      inputString: '', 
      inputObject: {},
      inputArray: [],
      fieldsToExtract: '[]', 
      stringsToConcatenate: '[]', 
      separator: '',
      delimiter: ',',
      index: 0,
      propertyName: '',
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
        transformType: { 
          label: 'Transformation Type', 
          type: 'select', 
          options: [
            {value: 'toUpperCase', label: 'To Uppercase'}, 
            {value: 'toLowerCase', label: 'To Lowercase'}, 
            {value: 'extractFields', label: 'Extract Fields from Object'}, 
            {value: 'concatenateStrings', label: 'Concatenate Strings'},
            {value: 'stringSplit', label: 'Split String to Array'},
            {value: 'arrayLength', label: 'Get Array Length'},
            {value: 'getItemAtIndex', label: 'Get Item From Array at Index'},
            {value: 'getObjectProperty', label: 'Get Property From Object'},
          ],
          defaultValue: 'toUpperCase'
        },
        inputString: { label: 'Input String (for case, split, concat)', type: 'textarea', placeholder: '{{input.text}}' },
        inputObject: { label: 'Input Object (for extractFields, getProperty)', type: 'json', placeholder: '{{input.data}}' },
        inputArray: { label: 'Input Array (for length, getItem, concat)', type: 'json', placeholder: '{{input.list}}' },
        fieldsToExtract: { label: 'Fields to Extract (JSON array of strings for extractFields)', type: 'json', placeholder: '["name", "email"]' },
        stringsToConcatenate: { label: 'Strings/Placeholders to Concatenate (JSON array for concatenateStrings)', type: 'json', placeholder: '["Hello ", "{{input.name}}", "!"]' },
        separator: { label: 'Separator (for concatenateStrings)', type: 'string', placeholder: '(empty for direct join)' },
        delimiter: { label: 'Delimiter (for stringSplit)', type: 'string', placeholder: ',' },
        index: { label: 'Index (for getItemAtIndex, 0-based)', type: 'number', placeholder: '0' },
        propertyName: { label: 'Property Name (for getObjectProperty)', type: 'string', placeholder: 'user.name' },
        ...GENERIC_RETRY_CONFIG_SCHEMA,
        ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input_data'],
    outputHandles: ['output_data', 'status', 'error_message'],
  },
  {
    type: 'executeFlowGroup',
    name: 'Execute Flow Group',
    icon: Layers, 
    description: 'Executes an encapsulated group of nodes as a sub-flow. Supports retries and on-error webhook for the entire group execution.',
    category: 'group',
    defaultConfig: {
      flowGroupNodes: '[]', 
      flowGroupConnections: '[]', 
      inputMapping: '{}', 
      outputMapping: '{}',
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      flowGroupNodes: { label: 'Flow Group Nodes (JSON Array of Node definitions)', type: 'json', placeholder: '[{\n  "id":"sub_node_1", \n  "type":"logMessage", \n  "name":"Log in Group", \n  "position":{"x":10,"y":10},\n  "config":{"message":"Message from sub-flow {{inputMapping.dataFromParent}}"}\n}]', helperText: 'Define the nodes for this group.' },
      flowGroupConnections: { label: 'Flow Group Connections (JSON Array of Connection definitions)', type: 'json', placeholder: '[{\n  "sourceNodeId":"sub_node_1", \n  "targetNodeId":"sub_node_2", \n  "sourceHandle":"output"\n}]', helperText: 'Define connections between nodes in this group.' },
      inputMapping: { label: 'Input Mapping (JSON Object)', type: 'json', placeholder: '{\n  "internalInputName": "{{parentWorkflow.someNode.output}}",\n  "dataFromParent": "{{trigger.some_data}}"\n}', helperText: 'Map parent data to group inputs. Access mapped inputs inside group nodes using their "internalInputName".' },
      outputMapping: { label: 'Output Mapping (JSON Object)', type: 'json', placeholder: '{\n  "parentOutputName": "{{group_node_id.result}}"\n}', helperText: 'Map group results to parent outputs. This node will output these mapped values.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'], 
    outputHandles: ['output', 'status', 'error_message'], 
  },
  {
    type: 'forEach',
    name: 'For Each Loop',
    icon: Repeat,
    description: 'Iterates over an array and executes a sub-flow for each item. Supports "continue on error", retries for the whole loop, and on-error webhook if the loop fails.',
    category: 'iteration',
    defaultConfig: {
      inputArrayPath: '',
      iterationNodes: '[]',
      iterationConnections: '[]',
      iterationResultSource: '', 
      continueOnError: false,
      retry: {}, 
      onErrorWebhook: undefined,
    },
    configSchema: {
      inputArrayPath: { label: 'Input Array Path', type: 'string', placeholder: '{{api_node.response.users}}', helperText: 'Placeholder for the array to iterate over.' },
      iterationNodes: { label: 'Iteration Nodes (JSON Array of Node definitions)', type: 'json', placeholder: '[{\n  "id":"loop_log", \n  "type":"logMessage", \n  "name":"Log Item", \n  "position":{"x":10,"y":10},\n  "config":{"message":"Processing item: {{item.name}}"}\n}]', helperText: 'Nodes to execute for each item. Use {{item.property}} to access current item data.' },
      iterationConnections: { label: 'Iteration Connections (JSON Array of Connection definitions)', type: 'json', placeholder: '[]', helperText: 'Connections between nodes within the iteration sub-flow.' },
      iterationResultSource: { label: 'Iteration Result Source (Optional Placeholder)', type: 'string', placeholder: '{{last_node_in_subflow.output}}', helperText: 'Placeholder to extract a specific value from each iteration\'s data. If omitted, the entire output of the last node in each sub-flow iteration is collected.' },
      continueOnError: { label: 'Continue On Error', type: 'boolean', defaultValue: false, helperText: 'If true, loop continues if an iteration errors; results will show individual statuses.'},
      ...GENERIC_RETRY_CONFIG_SCHEMA, 
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input_array_data'], 
    outputHandles: ['results', 'status', 'error_message'], 
  },
  {
    type: 'whileLoop',
    name: 'While Loop',
    icon: RotateCcw, 
    description: 'Executes a sub-flow repeatedly as long as a condition is true. Condition is evaluated before each iteration. Supports retries for the whole loop and on-error webhook if the loop fails.',
    category: 'iteration',
    defaultConfig: {
      condition: '',
      loopNodes: '[]',
      loopConnections: '[]',
      maxIterations: 100, 
      retry: {}, 
      onErrorWebhook: undefined,
    },
    configSchema: {
      condition: { label: 'Loop Condition (evaluates to boolean)', type: 'string', placeholder: '{{data.status}} === "pending" || {{counter.value}} < 10', helperText: 'The loop continues as long as this condition is true. Evaluated before each iteration.' },
      loopNodes: { label: 'Loop Nodes (JSON Array of Node definitions)', type: 'json', placeholder: '[{\n  "id":"loop_action", \n  "type":"httpRequest", \n  ...\n}]', helperText: 'Nodes to execute in each iteration. These nodes should eventually affect the loop condition.' },
      loopConnections: { label: 'Loop Connections (JSON Array of Connection definitions)', type: 'json', placeholder: '[]', helperText: 'Connections between nodes within the loop sub-flow.' },
      maxIterations: { label: 'Max Iterations (Optional, Default 100)', type: 'number', defaultValue: 100, placeholder: '100', helperText: 'Safety limit to prevent infinite loops.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input_data'], 
    outputHandles: ['iterations_completed', 'status', 'error_message'],
  },
  {
    type: 'parallel',
    name: 'Parallel Execution',
    icon: GitFork, 
    description: 'Executes multiple branches of nodes concurrently. Collects results from all branches. Supports retries for the whole block and on-error webhook if it fails.',
    category: 'control', 
    defaultConfig: {
      branches: '[]', 
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      branches: { 
        label: 'Branches (JSON Array of Branch definitions)', 
        type: 'json', 
        placeholder: '[{\n  "id": "branch_1",\n  "name": "Image Processing",\n  "nodes": [{"id":"img_op_1", "type":"aiTask", ...}],\n  "connections": [],\n  "inputMapping": {"img_data": "{{parent.image_url}}"},\n  "outputSource": "{{img_op_1.processed_image_url}}"\n},\n{\n  "id": "branch_2",\n  "name": "Metadata Fetch",\n  "nodes": [{"id":"meta_fetch_1", "type":"httpRequest", ...}],\n  "connections": [],\n  "inputMapping": {"item_id": "{{parent.item_id}}"},\n  "outputSource": "{{meta_fetch_1.response}}"\n}]',
        helperText: 'Define branches to run in parallel. Each branch has id, nodes, connections, optional inputMapping, and optional outputSource.'
      },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'], 
    outputHandles: ['results', 'status', 'error_message'], 
  },
  {
    type: 'youtubeFetchTrending',
    name: 'YouTube: Fetch Trending',
    icon: TrendingUp,
    description: 'Fetches trending videos from YouTube (conceptual - currently logs intent). Requires YOUTUBE_API_KEY env var. Supports retries and on-error webhook.',
    category: 'trigger',
    defaultConfig: { region: 'US', maxResults: 3, apiKey: '{{env.YOUTUBE_API_KEY}}', retry: {}, onErrorWebhook: undefined },
    configSchema: {
      region: { label: 'Region Code', type: 'string', defaultValue: 'US', placeholder: 'US, GB, IN, etc.' },
      maxResults: { label: 'Max Results', type: 'number', defaultValue: 3, placeholder: 'Number of videos' },
      apiKey: { label: 'YouTube API Key', type: 'string', placeholder: '{{env.YOUTUBE_API_KEY}}', helperText:"Set YOUTUBE_API_KEY in environment."},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    outputHandles: ['videos', 'status', 'error_message'],
  },
  {
    type: 'youtubeDownloadVideo',
    name: 'YouTube: Download Video',
    icon: DownloadCloud,
    description: 'Downloads a YouTube video (conceptual - currently logs intent). Supports retries and on-error webhook.',
    category: 'action',
    defaultConfig: { videoUrl: '', quality: 'best', retry: {}, onErrorWebhook: undefined },
    configSchema: {
      videoUrl: { label: 'Video URL', type: 'string', placeholder: '{{prev_node.videos[0].url}}' },
      quality: { label: 'Quality', type: 'select', options: ['best', '1080p', '720p', '480p'], defaultValue: 'best' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['filePath', 'status', 'error_message'],
  },
  {
    type: 'videoConvertToShorts',
    name: 'Video: Convert to Shorts',
    icon: Scissors,
    description: 'Converts a video to a short format (conceptual - currently logs intent). Supports retries and on-error webhook.',
    category: 'action',
    defaultConfig: { inputFile: '', duration: 60, strategy: 'center_cut', retry: {}, onErrorWebhook: undefined },
    configSchema: {
      inputFile: { label: 'Input Video File Path', type: 'string', placeholder: '{{download_node.filePath}}' },
      duration: { label: 'Short Duration (seconds)', type: 'number', defaultValue: 60 },
      strategy: { label: 'Conversion Strategy', type: 'select', options: ['center_cut', 'first_segment', 'ai_highlights'], defaultValue: 'center_cut'},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['shortFilePath', 'status', 'error_message'],
  },
  {
    type: 'youtubeUploadShort',
    name: 'YouTube: Upload Short',
    icon: UploadCloud,
    description: 'Uploads a video short to YouTube (conceptual - currently logs intent). Requires YOUTUBE_OAUTH_TOKEN env var. Supports retries and on-error webhook.',
    category: 'action',
    defaultConfig: { filePath: '', title: '', description: '', tags: [], privacy: 'public', credentials: '{{secret.YOUTUBE_OAUTH_TOKEN}}', retry: {}, onErrorWebhook: undefined },
    configSchema: {
      filePath: { label: 'Video File Path', type: 'string', placeholder: '{{convert_node.shortFilePath}}' },
      title: { label: 'Title', type: 'string', placeholder: 'My Awesome Short' },
      description: { label: 'Description', type: 'textarea' },
      tags: { label: 'Tags (comma-separated)', type: 'string', placeholder: 'short, funny, tech' },
      privacy: { label: 'Privacy', type: 'select', options: ['public', 'private', 'unlisted'], defaultValue: 'public'},
      credentials: { label: 'YouTube Credentials/Token', type: 'string', placeholder: '{{secret.YOUTUBE_OAUTH_TOKEN}}', helperText: "Use {{secret.YOUTUBE_OAUTH_TOKEN}} or {{env.YOUTUBE_OAUTH_TOKEN}}."},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['uploadStatus', 'videoId', 'status', 'error_message'],
  },
  {
    type: 'workflowNode', 
    name: 'Custom Action', 
    icon: WorkflowIcon,
    description: 'A generic, configurable step in the workflow. Used by AI when a specific node type isn\'t matched. Supports retries and on-error webhook.',
    category: 'action', 
    defaultConfig: { task_description: '', parameters: {}, retry: {}, onErrorWebhook: undefined },
    configSchema: {
      task_description: {label: 'Task Description', type: 'string', placeholder: 'Describe what this node should do'},
      parameters: { label: 'Parameters (JSON)', type: 'textarea', placeholder: '{\n  "custom_param": "value"\n}'},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'unknown',
    name: 'Unknown Node',
    icon: HelpCircle,
    description: 'Represents an unrecognized or AI-generated node type that needs mapping.',
    category: 'unknown',
    defaultConfig: { error: 'Unknown node type from AI', originalType: '', originalConfig: {} },
    configSchema: {
      originalType: { label: 'Original AI Type', type: 'string' },
      originalConfig: { label: 'Original AI Config (JSON)', type: 'textarea' },
    },
    inputHandles: ['input'],
    outputHandles: ['output'],
  }
];

export const AI_NODE_TYPE_MAPPING: Record<string, string> = {
  // General & Triggers
  'trigger': 'trigger',
  'manual trigger': 'trigger',
  'start': 'trigger',
  'webhook': 'httpRequest', 
  'http trigger': 'httpRequest',
  'schedule': 'schedule',
  'cron': 'schedule',
  'cron job': 'schedule',
  'timed trigger': 'schedule',
  
  // Actions & I/O
  'httprequest': 'httpRequest',
  'http request': 'httpRequest',
  'api call': 'httpRequest',
  'fetch data': 'httpRequest',
  'get request': 'httpRequest',
  'post request': 'httpRequest',
  'put request': 'httpRequest',
  'delete request': 'httpRequest',
  'patch request': 'httpRequest',
  'sendemail': 'sendEmail',
  'send email': 'sendEmail',
  'email': 'sendEmail',
  'notify by email': 'sendEmail',
  'databasequery': 'databaseQuery',
  'database query': 'databaseQuery',
  'sql query': 'databaseQuery',
  'query database': 'databaseQuery',
  'read database': 'databaseQuery',
  'write database': 'databaseQuery', 
  'logmessage': 'logMessage',
  'log message': 'logMessage',
  'print to console': 'logMessage',
  'debug log': 'logMessage',
  'output message': 'logMessage',

  // Logic & Data
  'parsejson': 'parseJson',
  'parse json': 'parseJson',
  'json transform': 'parseJson',
  'extract from json': 'parseJson',
  'conditionallogic': 'conditionalLogic',
  'conditional': 'conditionalLogic',
  'condition': 'conditionalLogic',
  'if/else': 'conditionalLogic',
  'if condition': 'conditionalLogic',
  'branch': 'conditionalLogic', 
  'filter': 'conditionalLogic', 
  'switch': 'conditionalLogic',
  'route based on condition': 'conditionalLogic',
  'datatransform': 'dataTransform',
  'transform data': 'dataTransform',
  'manipulate data': 'dataTransform',
  'map data': 'dataTransform',
  'script': 'dataTransform', 
  'custom script': 'dataTransform',
  'run code': 'dataTransform',
  'javascript': 'dataTransform',
  'code': 'dataTransform',
  'uppercase': 'dataTransform', 
  'touppercase': 'dataTransform',
  'lowercase': 'dataTransform',
  'tolowercase': 'dataTransform',
  'extractfields': 'dataTransform',
  'concatenate': 'dataTransform',
  'concatenatestrings': 'dataTransform',
  'stringsplit': 'dataTransform',
  'split string': 'dataTransform',
  'arraylength': 'dataTransform',
  'get array length': 'dataTransform',
  'count items in array': 'dataTransform',
  'getitematindex': 'dataTransform',
  'get item from array': 'dataTransform',
  'getobjectproperty': 'dataTransform',
  'get property from object': 'dataTransform',

  // AI
  'aitask': 'aiTask',
  'ai task': 'aiTask',
  'llm call': 'aiTask',
  'genai': 'aiTask',
  'generate text': 'aiTask',
  'summarize': 'aiTask', 
  'translate': 'aiTask',
  'analyze sentiment': 'aiTask',
  'classify text': 'aiTask',

  // Grouping / Sub-flows
  'executeflowgroup': 'executeFlowGroup',
  'execute flow group': 'executeFlowGroup',
  'sub workflow': 'executeFlowGroup',
  'sub-workflow': 'executeFlowGroup',
  'run group': 'executeFlowGroup',
  'call workflow': 'executeFlowGroup',
  'encapsulate flow': 'executeFlowGroup',

  // Iteration
  'foreach': 'forEach',
  'for each': 'forEach',
  'loop': 'forEach', 
  'iterate': 'forEach',
  'process list': 'forEach',
  'whileloop': 'whileLoop',
  'while loop': 'whileLoop',
  'conditional loop': 'whileLoop',
  'repeat while': 'whileLoop',

  // Control Flow 
  'parallel': 'parallel',
  'concurrent': 'parallel',
  'fork': 'parallel',
  'fan out': 'parallel',
  'run in parallel': 'parallel',

  // YouTube Specific (Conceptual)
  'youtubefetchtrending': 'youtubeFetchTrending',
  'youtube fetch trending': 'youtubeFetchTrending',
  'get trending youtube videos': 'youtubeFetchTrending',
  'fetch youtube videos': 'youtubeFetchTrending',
  'youtubedownloadvideo': 'youtubeDownloadVideo',
  'youtube download': 'youtubeDownloadVideo',
  'download youtube video': 'youtubeDownloadVideo',
  'save youtube video': 'youtubeDownloadVideo',
  'videoconverttoshorts': 'videoConvertToShorts',
  'video convert to shorts': 'videoConvertToShorts',
  'make youtube short': 'videoConvertToShorts',
  'edit video for shorts': 'videoConvertToShorts',
  'create short video': 'videoConvertToShorts',
  'youtubeuploadshort': 'youtubeUploadShort',
  'youtube upload short': 'youtubeUploadShort',
  'post youtube short': 'youtubeUploadShort',
  'upload youtube short': 'youtubeUploadShort',
  'youtube upload': 'youtubeUploadShort', 
  
  // Default/Fallback
  'default': 'workflowNode', 
  'customaction': 'workflowNode',
  'custom action': 'workflowNode',
  'generic step': 'workflowNode',
  'workflowstep': 'workflowNode',
  'action': 'workflowNode',
  'task': 'workflowNode',
  'step': 'workflowNode',
  'workflownode': 'workflowNode', 
  'unknown': 'unknown'
};

export const getDataTransformIcon = (transformType?: string): LucideIcon => {
  switch (transformType) {
    case 'toUpperCase':
    case 'toLowerCase':
      return CaseSensitive;
    case 'stringSplit':
      return SplitSquareHorizontal;
    case 'arrayLength':
    case 'getItemAtIndex':
      return ListOrdered;
    case 'getObjectProperty':
    case 'extractFields':
      return Milestone; 
    case 'concatenateStrings':
      return Combine;
    default:
      return FunctionSquare;
  }
}
