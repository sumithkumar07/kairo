
import type { AvailableNodeType, RetryConfig, BranchConfig, OnErrorWebhookConfig, ManualInputFieldSchema } from '@/types/workflow';
import { Bot, Braces, FileJson, FunctionSquare, GitBranch, HelpCircle, LogOut, Network, Play, Terminal, Workflow as WorkflowIcon, Database, Mail, Clock, Youtube, TrendingUp, DownloadCloud, Scissors, UploadCloud, Filter, Combine, SplitSquareHorizontal, ListOrdered, Milestone, CaseSensitive, GitFork, Layers, Repeat, RotateCcw, VenetianMask, LucideIcon, UserCheck, Edit3, ClipboardCheck, Sigma, Percent, ListPlus, ListX, Share2, FilePlus2, Timer, CalendarDays, Webhook, KeyRound, Sheet, MessageSquare, CreditCard, AlertCircle, Github, UserPlus, Smartphone } from 'lucide-react';

export const NODE_WIDTH = 200; 
export const NODE_HEIGHT = 100; 

const GENERIC_RETRY_CONFIG_SCHEMA = {
  retry: { 
    label: 'Retry Config (JSON, Optional)', 
    type: 'json', 
    placeholder: '{\n  "attempts": 3,\n  "delayMs": 1000,\n  "backoffFactor": 2,\n  "retryOnStatusCodes": [500, 503, 429],\n  "retryOnErrorKeywords": ["timeout", "unavailable"]\n}',
    helperText: 'Define retry strategy: attempts, delayMs, backoffFactor (e.g., 2 for exponential), retryOnStatusCodes (for HTTP nodes), retryOnErrorKeywords (case-insensitive keywords to match in error messages for any node type). All fields optional.',
    defaultValue: {} as RetryConfig
  }
};

const GENERIC_ON_ERROR_WEBHOOK_SCHEMA = {
  onErrorWebhook: {
    label: 'On-Error Webhook (JSON, Optional)',
    type: 'json',
    placeholder: '{\n  "url": "https://my-error-logger.com/log",\n  "method": "POST",\n  "headers": {"X-API-Key": "{{env.ERROR_API_KEY}}"},\n  "bodyTemplate": {\n    "nodeId": "{{failed_node_id}}",\n    "nodeName": "{{failed_node_name}}",\n    "errorMessage": "{{error_message}}",\n    "timestamp": "{{timestamp}}",\n    "workflowSnapshot": "{{workflow_data_snapshot_json}}"\n  }\n}',
    helperText: 'If node fails after all retries, send details to this webhook. Placeholders for body/headers: {{failed_node_id}}, {{failed_node_name}}, {{error_message}}, {{timestamp}}, {{workflow_data_snapshot_json}} (full workflow data as JSON string), and {{env.VAR_NAME}}. This is a fire-and-forget notification. It can be used for simple alerts or to send error details to an endpoint that acts as a Dead-Letter Queue (DLQ) processor or triggers a dedicated error-handling workflow. The `workflow_data_snapshot_json` payload is crucial for DLQ scenarios as it provides the complete context for later analysis or reprocessing.',
    defaultValue: undefined as (OnErrorWebhookConfig | undefined)
  }
};

export const AVAILABLE_NODES_CONFIG: AvailableNodeType[] = [
  {
    type: 'webhookTrigger',
    name: 'Webhook Trigger',
    icon: Webhook,
    description: 'Triggers workflow via HTTP POST to a unique URL. Outputs request data. Base URL: /api/workflow-webhooks/',
    category: 'trigger',
    defaultConfig: { 
      pathSuffix: 'my-hook', 
      securityToken: '',
      simulatedRequestBody: '{"message": "Hello from simulated webhook!"}',
      simulatedRequestHeaders: '{"Content-Type": "application/json", "X-Custom-Header": "SimValue"}',
      simulatedRequestQuery: '{"param1": "test", "param2": "true"}',
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      pathSuffix: { label: 'Path Suffix', type: 'string', placeholder: 'e.g., customer-updates-hook', helperText: "Unique path for this webhook. Full URL: /api/workflow-webhooks/YOUR_SUFFIX", required: true },
      securityToken: { label: 'Security Token (Optional)', type: 'string', placeholder: '{{credential.MyWebhookToken}} or {{env.MY_WEBHOOK_TOKEN}}', helperText: "If set, incoming request must have 'X-Webhook-Token' header with this value." },
      simulatedRequestBody: { label: 'Simulated Request Body (JSON for Simulation)', type: 'json', defaultValue: '{"message": "Hello!"}', helperText: "JSON data for the requestBody output during simulation." },
      simulatedRequestHeaders: { label: 'Simulated Request Headers (JSON for Simulation)', type: 'json', defaultValue: '{}', helperText: "JSON data for the requestHeaders output during simulation." },
      simulatedRequestQuery: { label: 'Simulated Request Query Params (JSON for Simulation)', type: 'json', defaultValue: '{}', helperText: "JSON data for the requestQuery output during simulation." },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: [],
    outputHandles: ['requestBody', 'requestHeaders', 'requestQuery', 'status', 'error_message'],
  },
  {
    type: 'fileSystemTrigger',
    name: 'File System Trigger',
    icon: FilePlus2,
    description: 'Conceptually triggers on file system events (simulated). Supports retries and on-error webhook.',
    category: 'trigger',
    defaultConfig: { 
      directoryPath: '/uploads', 
      eventTypes: '["create", "modify"]', 
      fileNamePattern: '*.csv', 
      pollingIntervalSeconds: 60,
      simulatedFileEvent: '{"eventType": "create", "filePath": "/uploads/new_report.csv", "fileName": "new_report.csv"}',
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      directoryPath: { label: 'Directory Path', type: 'string', placeholder: '/mnt/shared_drive/input_files or {{env.WATCH_FOLDER}}', required: true },
      eventTypes: { label: 'Event Types (JSON Array)', type: 'json', placeholder: '["create", "modify", "delete"]', helperText: 'e.g., create, modify, delete.', required: true },
      fileNamePattern: { label: 'File Name Pattern (Glob, Optional)', type: 'string', placeholder: '*.txt, report-*.csv' },
      pollingIntervalSeconds: { label: 'Polling Interval (seconds, Conceptual)', type: 'number', defaultValue: 60, helperText: 'Conceptual interval for checking for new files.' },
      simulatedFileEvent: { label: 'Simulated File Event (JSON)', type: 'json', placeholder: '{"eventType": "create", "filePath": "/sim/data.txt", "fileName":"data.txt"}', helperText: 'JSON data representing the file event this trigger will output during simulation.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: [],
    outputHandles: ['fileEvent', 'status', 'error_message'],
  },
  {
    type: 'getEnvironmentVariable',
    name: 'Get Environment Variable',
    icon: KeyRound,
    description: 'Retrieves the value of a specified environment variable. Outputs `value` or `null`. Can fail if not set.',
    category: 'io',
    defaultConfig: { variableName: '', failIfNotSet: false, retry: {}, onErrorWebhook: undefined, },
    configSchema: {
      variableName: { label: 'Variable Name', type: 'string', placeholder: 'e.g., MY_API_KEY', required: true, helperText: 'The name of the environment variable to retrieve.' },
      failIfNotSet: { label: 'Fail if Not Set', type: 'boolean', defaultValue: false, helperText: 'If true, the node will error if the environment variable is not found.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['value', 'status', 'error_message'],
  },
  {
    type: 'httpRequest',
    name: 'HTTP Request',
    icon: Network,
    description: 'Makes an HTTP request. Supports retries, on-error webhook, and simulation.',
    category: 'action', 
    defaultConfig: { 
        url: '', 
        method: 'GET', 
        headers: '{\n  "Authorization": "{{credential.MyApiToken}}"\n}', 
        body: '', 
        retry: {}, 
        onErrorWebhook: undefined, 
        simulatedResponse: '{"message": "Simulated HTTP success"}',
        simulatedStatusCode: 200 
    },
    configSchema: {
      url: { label: 'URL', type: 'string', placeholder: 'https://api.example.com/data', required: true },
      method: { 
        label: 'Method', 
        type: 'select', 
        options: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
        defaultValue: 'GET',
        required: true,
      },
      headers: { label: 'Headers (JSON)', type: 'textarea', placeholder: '{\n  "Content-Type": "application/json",\n  "Authorization": "Bearer {{credential.MyApiToken}}"\n}', helperText: "Use {{credential.CRED_NAME}} for secrets." },
      body: { label: 'Body (JSON/Text)', type: 'textarea', placeholder: '{\n  "key": "value"\n}' },
      simulatedResponse: { label: 'Simulated Response Body (JSON/Text for Simulation Mode)', type: 'json', placeholder: '{"data": "mock_value"}', helperText: 'Response body content returned by this node when in simulation mode.'},
      simulatedStatusCode: { label: 'Simulated Status Code (Number for Simulation)', type: 'number', defaultValue: 200, placeholder: '200', helperText: 'Definitive HTTP status code to simulate (e.g., 200, 404, 500). Used to test error handling and retries.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['response', 'status_code', 'status', 'error_message'],
  },
  {
    type: 'schedule',
    name: 'Schedule',
    icon: Clock,
    description: 'Triggers workflow on a defined schedule.',
    category: 'trigger',
    defaultConfig: { cron: '0 * * * *' }, 
    configSchema: {
      cron: { label: 'Cron Expression', type: 'string', defaultValue: '0 * * * *', placeholder: 'e.g., 0 9 * * MON', required: true },
    },
    inputHandles: [],
    outputHandles: ['triggered_at'],
  },
  {
    type: 'sendEmail',
    name: 'Send Email',
    icon: Mail,
    description: 'Sends an email. Supports retries, on-error webhook, and simulation. Configure mail server via EMAIL_ env vars.',
    category: 'action',
    defaultConfig: { to: '', subject: '', body: '', retry: {}, onErrorWebhook: undefined, simulatedMessageId: 'simulated-email-id-123' },
    configSchema: {
      to: { label: 'To', type: 'string', placeholder: 'recipient@example.com or {{input.email}}', required: true },
      subject: { label: 'Subject', type: 'string', placeholder: 'Workflow Notification: {{input.status}}', required: true },
      body: { label: 'Body (HTML or Text)', type: 'textarea', placeholder: 'Details: {{input.details}}', required: true },
      simulatedMessageId: { label: 'Simulated Message ID (String for Simulation Mode)', type: 'string', defaultValue: 'simulated-email-id-123', helperText: 'Message ID returned by this node when in simulation mode.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['messageId', 'status', 'error_message'],
  },
  {
    type: 'databaseQuery',
    name: 'Database Query',
    icon: Database,
    description: 'Executes a SQL query. Supports retries, on-error webhook, and simulation. Use {{credential.DB_CONNECTION_STRING}} or set DB_CONNECTION_STRING env var.',
    category: 'io',
    defaultConfig: { queryText: 'SELECT * FROM my_table WHERE id = $1;', queryParams: '["{{input.id}}"]', retry: {}, onErrorWebhook: undefined, simulatedResults: '[]', simulatedRowCount: 0 },
    configSchema: {
      queryText: { label: 'SQL Query (use $1, $2 for parameters)', type: 'textarea', placeholder: 'SELECT * FROM users WHERE id = $1 AND status = $2;', required: true },
      queryParams: { label: 'Query Parameters (JSON array)', type: 'json', placeholder: '["{{input.userId}}", "active"]', helperText: "Array of values or placeholders for $1, $2, etc." },
      simulatedResults: { label: 'Simulated Results (JSON Array for Simulation Mode)', type: 'json', placeholder: '[{"column1": "mock_data", "column2": 123}]', helperText: 'Results array returned by this node when in simulation mode.' },
      simulatedRowCount: { label: 'Simulated Row Count (Number for Simulation Mode)', type: 'number', defaultValue: 0, helperText: 'Row count returned by this node when in simulation mode. If simulatedResults is provided, this will be its length unless explicitly set.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'], 
    outputHandles: ['results', 'rowCount', 'status', 'error_message'],
  },
  {
    type: 'googleCalendarListEvents',
    name: 'Google Calendar: List Events (Simulated)',
    icon: CalendarDays,
    description: 'Simulates fetching events from Google Calendar. Real execution would require Google OAuth setup. Supports retries and on-error webhook.',
    category: 'integrations',
    isAdvanced: true,
    defaultConfig: { 
        maxResults: 10, 
        simulated_config: { events: [{"summary": "Team Sync", "start": {"dateTime": "2024-09-15T10:00:00-07:00"}, "end": {"dateTime": "2024-09-15T11:00:00-07:00"}}, {"summary": "Project Deadline", "start": {"date": "2024-09-20"}, "end": {"date": "2024-09-21"}}]}, 
        retry: {}, 
        onErrorWebhook: undefined 
    },
    configSchema: {
      maxResults: { label: 'Max Results (Optional)', type: 'number', defaultValue: 10, placeholder: '10', helperText: 'Maximum number of events to return.' },
      simulated_config: { label: 'Simulated Events (JSON for Simulation Mode)', type: 'json', placeholder: '{"events": [{"summary": "My Event", "start": {"dateTime": "YYYY-MM-DDTHH:mm:ssZ"}}]}', helperText: 'Event objects this node will output during simulation. Real execution requires OAuth.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'], 
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'parseJson',
    name: 'Parse JSON',
    icon: Braces,
    description: 'Parses a JSON string and extracts data using a path.',
    category: 'logic',
    defaultConfig: { jsonString: '', path: '' },
    configSchema: {
      jsonString: { label: 'JSON Input (e.g. {{prev_node.response}})', type: 'textarea', placeholder: '{{previous_node.response}}', required: true },
      path: { label: 'Extraction Path (e.g. $.data.items[0].name)', type: 'string', placeholder: '$.data.items[0].name' },
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'logMessage',
    name: 'Log Message',
    icon: Terminal,
    description: 'Logs a message to the workflow execution log. Useful for debugging.',
    category: 'io',
    defaultConfig: { message: 'Workflow log: {{input}}' },
    configSchema: {
      message: { label: 'Message to Log', type: 'textarea', placeholder: 'Current value: {{data.value}}', required: true, helperText: 'You can use placeholders to log dynamic data.' },
    },
    inputHandles: ['input'],
    outputHandles: ['output'],
  },
  {
    type: 'aiTask',
    name: 'AI Task',
    icon: Bot,
    description: 'Performs a task using a GenAI model. Supports retries, on-error webhook, and simulation.',
    category: 'ai',
    defaultConfig: { prompt: '', model: 'googleai/gemini-1.5-flash-latest', retry: {}, onErrorWebhook: undefined, simulatedOutput: 'This is a simulated AI response.' },
    configSchema: {
      prompt: { label: 'Prompt', type: 'textarea', placeholder: 'Summarize the following text: {{input.text}}', required: true },
      model: { label: 'Model ID', type: 'string', defaultValue: 'googleai/gemini-1.5-flash-latest', placeholder: 'e.g., googleai/gemini-1.5-pro-latest', required: true },
      simulatedOutput: { label: 'Simulated AI Output (String for Simulation Mode)', type: 'string', placeholder: 'This is a simulated AI response.', helperText: 'Text output from the AI model when in simulation mode.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'conditionalLogic',
    name: 'Condition',
    icon: Filter,
    description: 'Evaluates a condition. Use its boolean `result` in a subsequent node\'s `_flow_run_condition` config field (e.g. {{this_node_id.result}}) to control execution.',
    category: 'logic',
    defaultConfig: { condition: '' },
    configSchema: {
        condition: { label: 'Condition string (e.g., {{data.value}} == "success", {{data.count}} > 10, {{data.isValid}} === true)', type: 'string', placeholder: '{{data.temperature}} > 30', required: true },
    },
    inputHandles: ['input'],
    outputHandles: ['result'],
  },
  {
    type: 'executeFlowGroup',
    name: 'Execute Flow Group',
    icon: Layers, 
    description: 'Executes an encapsulated group of nodes as a sub-flow. Supports retries and on-error webhook for the entire group execution.',
    category: 'group',
    isAdvanced: true,
    defaultConfig: {
      flowGroupNodes: '[]', 
      flowGroupConnections: '[]', 
      inputMapping: '{}', 
      outputMapping: '{}',
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      flowGroupNodes: { label: 'Flow Group Nodes (JSON Array of Node definitions)', type: 'json', placeholder: '[{\n  "id":"sub_node_1", \n  "type":"logMessage", \n  "name":"Log in Group", \n  "position":{"x":10,"y":10},\n  "config":{"message":"Message from sub-flow {{inputMapping.dataFromParent}}"}\n}]', helperText: 'Define the nodes for this group.', required: true },
      flowGroupConnections: { label: 'Flow Group Connections (JSON Array of Connection definitions)', type: 'json', placeholder: '[{\n  "sourceNodeId":"sub_node_1", \n  "targetNodeId":"sub_node_2", \n  "sourceHandle":"output"\n}]', helperText: 'Define connections between nodes in this group.' },
      inputMapping: { label: 'Input Mapping (JSON Object)', type: 'json', placeholder: '{\n  "internalInputName": "{{parentWorkflow.someNode.output}}",\n  "dataFromParent": "{{trigger.some_data}}"\n}', helperText: 'Map parent data to group inputs. Access mapped inputs inside group nodes using their "internalInputName".' },
      outputMapping: { label: 'Output Mapping (JSON Object)', type: 'json', placeholder: '{\n  "parentOutputName": "{{group_node_id.result}}"\n}', helperText: 'Map group results to parent outputs. This node will output these mapped values.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'], 
    outputHandles: ['output', 'status', 'error_message'], 
  },
  {
    type: 'forEach',
    name: 'For Each Loop',
    icon: Repeat,
    description: 'Iterates over an array and executes a sub-flow for each item. Supports "continue on error", retries for the whole loop, and on-error webhook if the loop fails.',
    category: 'iteration',
    defaultConfig: {
      inputArrayPath: '',
      iterationNodes: '[]',
      iterationConnections: '[]',
      iterationResultSource: '', 
      continueOnError: false,
      retry: {}, 
      onErrorWebhook: undefined,
    },
    configSchema: {
      inputArrayPath: { label: 'Input Array Path', type: 'string', placeholder: '{{api_node.response.users}}', helperText: 'Placeholder for the array to iterate over.', required: true },
      iterationNodes: { label: 'Iteration Nodes (JSON Array of Node definitions)', type: 'json', placeholder: '[{\n  "id":"loop_log", \n  "type":"logMessage", \n  "name":"Log Item", \n  "position":{"x":10,"y":10},\n  "config":{"message":"Processing item: {{item.name}}"}\n}]', helperText: 'Nodes to execute for each item. Use {{item.property}} to access current item data.', required: true },
      iterationConnections: { label: 'Iteration Connections (JSON Array of Connection definitions)', type: 'json', placeholder: '[]', helperText: 'Connections between nodes within the iteration sub-flow.' },
      iterationResultSource: { label: 'Iteration Result Source (Optional Placeholder)', type: 'string', placeholder: '{{last_node_in_subflow.output}}', helperText: 'Placeholder to extract a specific value from each iteration\'s data. If omitted, the entire output of the last executed node in each sub-flow iteration is collected.' },
      continueOnError: { label: 'Continue On Error', type: 'boolean', defaultValue: false, helperText: 'If true, loop continues if an iteration errors; results will show individual statuses.'},
      ...GENERIC_RETRY_CONFIG_SCHEMA, 
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input_array_data'], 
    outputHandles: ['results', 'status', 'error_message'], 
  },
  {
    type: 'whileLoop',
    name: 'While Loop',
    icon: RotateCcw, 
    description: 'Executes a sub-flow repeatedly as long as a condition is true. Condition is evaluated before each iteration. Supports retries for the whole loop and on-error webhook if the loop fails.',
    category: 'iteration',
    defaultConfig: {
      condition: '',
      loopNodes: '[]',
      loopConnections: '[]',
      maxIterations: 100, 
      retry: {}, 
      onErrorWebhook: undefined,
    },
    configSchema: {
      condition: { label: 'Loop Condition (evaluates to boolean)', type: 'string', placeholder: '{{data.status}} === "pending" || {{counter.value}} < 10', helperText: 'The loop continues as long as this condition is true. Evaluated before each iteration.', required: true },
      loopNodes: { label: 'Loop Nodes (JSON Array of Node definitions)', type: 'json', placeholder: '[{\n  "id":"loop_action", \n  "type":"httpRequest", \n  ...\n}]', helperText: 'Nodes to execute in each iteration. These nodes should eventually affect the loop condition.', required: true },
      loopConnections: { label: 'Loop Connections (JSON Array of Connection definitions)', type: 'json', placeholder: '[]', helperText: 'Connections between nodes within the loop sub-flow.' },
      maxIterations: { label: 'Max Iterations (Optional, Default 100)', type: 'number', defaultValue: 100, placeholder: '100', helperText: 'Safety limit to prevent infinite loops.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input_data'], 
    outputHandles: ['iterations_completed', 'status', 'error_message'],
  },
  {
    type: 'parallel',
    name: 'Parallel Execution',
    icon: GitFork, 
    description: 'Executes multiple branches of nodes concurrently, optionally limiting concurrency. Collects results from all branches. Supports retries for the whole block and on-error webhook if it fails.',
    category: 'control', 
    isAdvanced: true,
    defaultConfig: {
      branches: '[]',
      concurrencyLimit: 0,
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      branches: { 
        label: 'Branches (JSON Array of Branch definitions)', 
        type: 'json', 
        placeholder: '[{\n  "id": "branch_1",\n  "name": "Image Processing",\n  "nodes": [{"id":"img_op_1", "type":"aiTask", ...}],\n  "connections": [],\n  "inputMapping": {"img_data": "{{parent.image_url}}"},\n  "outputSource": "{{img_op_1.processed_image_url}}"\n}]',
        helperText: 'Define branches to run in parallel. Each branch has id, nodes, connections, optional inputMapping, and optional outputSource.',
        required: true,
      },
      concurrencyLimit: {
        label: 'Concurrency Limit (Optional)',
        type: 'number',
        defaultValue: 0,
        placeholder: 'e.g., 3 (0 or less means no limit)',
        helperText: 'Max number of branches to run at once. 0 or less means unlimited concurrency.'
      },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'], 
    outputHandles: ['results', 'status', 'error_message'], 
  },
  {
    type: 'manualInput',
    name: 'Manual Input (Simulated)',
    icon: UserCheck,
    description: 'Simulates a step requiring human input. Outputs pre-configured data. Supports retries and on-error webhook.',
    category: 'interaction',
    defaultConfig: {
      instructions: 'Please review and provide input.',
      inputFieldsSchema: '[{"id": "approval", "label": "Approve?", "type": "boolean", "defaultValue": true}]',
      simulatedResponse: '{"approval": true, "notes": "Simulated approval"}',
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      instructions: { label: 'User Instructions', type: 'textarea', placeholder: 'Describe what the user needs to do.', required: true },
      inputFieldsSchema: { label: 'Input Fields Schema (JSON Array)', type: 'json', placeholder: '[{"id":"field_id","label":"Field Label","type":"text"}]', helperText: 'Define the form fields for user input (id, label, type: text/textarea/number/boolean/select, options[] for select).', required: true },
      simulatedResponse: { label: 'Simulated Response (JSON)', type: 'json', placeholder: '{"field_id":"simulated_value"}', helperText: 'Data this node will output during simulation. This JSON object, when parsed, becomes the value available on the node\'s \'output\' handle and should be consistent with the structure defined by inputFieldsSchema.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'callExternalWorkflow',
    name: 'Call External Workflow',
    icon: Share2, 
    description: 'Calls another workflow by its ID (currently simulated). Define input/output mappings and simulated output. Supports retries and on-error webhook.',
    category: 'group',
    defaultConfig: {
      calledWorkflowId: '',
      inputMapping: '{}',
      outputMapping: '{}',
      simulatedOutput: '{"simulatedResult": "data from called workflow"}',
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      calledWorkflowId: { label: 'Called Workflow ID', type: 'string', placeholder: 'e.g., "customer_onboarding_flow_v2"', required: true },
      inputMapping: { label: 'Input Mapping (JSON)', type: 'json', placeholder: '{\n  "targetWorkflowInputName": "{{currentWorkflow.someNode.output}}"\n}', helperText: 'Map data from this workflow to the inputs of the called workflow.' },
      outputMapping: { label: 'Output Mapping (JSON)', type: 'json', placeholder: '{\n  "currentWorkflowOutputName": "{{calledWorkflow.result}}"\n}', helperText: 'Map outputs from the called workflow (from its simulatedOutput, via {{calledWorkflow.property}} placeholders) back to this node\'s output handle.' },
      simulatedOutput: { label: 'Simulated Output (JSON for called workflow)', type: 'json', placeholder: '{\n  "result": "mock data", "details": {"status":"ok"}\n}', helperText: 'Data this node will output to simulate the called workflow\'s execution. Structure this as if it were the entire output object of the called workflow. This JSON object is the direct data source that `outputMapping` placeholders (like `{{calledWorkflow.some_key}}`) will reference.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'delay',
    name: 'Delay',
    icon: Timer,
    description: 'Pauses workflow execution for a specified duration in milliseconds.',
    category: 'control',
    defaultConfig: { delayMs: 1000, retry: {}, onErrorWebhook: undefined, },
    configSchema: {
      delayMs: { label: 'Delay (milliseconds)', type: 'number', defaultValue: 1000, required: true, placeholder: 'e.g., 5000 for 5 seconds', helperText: 'The duration for which the workflow will pause.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'googleSheetsAppendRow',
    name: 'Google Sheets: Append Row',
    icon: Sheet,
    description: 'Appends a row to a Google Sheet (simulated live). Requires Google OAuth.',
    category: 'integrations',
    isAdvanced: true,
    defaultConfig: { spreadsheetId: '', range: 'Sheet1', values: '[["{{input.name}}", "{{input.email}}"]]', retry: {}, onErrorWebhook: undefined, simulated_config: { updatedRange: 'Sheet1!A1:B1', updatedRows: 1 } },
    configSchema: {
      spreadsheetId: { label: 'Spreadsheet ID', type: 'string', placeholder: 'Enter your Google Sheet ID here', required: true, helperText: 'Find this in your Google Sheet URL.' },
      range: { label: 'Sheet Name/Range', type: 'string', defaultValue: 'Sheet1', placeholder: 'Sheet1!A1', helperText: 'The sheet name, e.g., "Sheet1", or a range like "Sheet1!A1". Appends after the last row of the specified range/sheet.', required: true },
      values: { label: 'Values to Append (JSON Array of Arrays)', type: 'json', placeholder: '[["{{input.name}}", "{{input.email}}"]]', helperText: 'An array of rows, where each row is an array of cell values.', required: true },
      simulated_config: { label: 'Simulated Output (JSON)', type: 'json', placeholder: '{"updatedRange": "Sheet1!A1:B1"}', helperText: 'Mock response for simulation mode. Live mode for this node is simulated and will also return this data.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'slackPostMessage',
    name: 'Slack: Post Message',
    icon: MessageSquare,
    description: 'Posts a message to a Slack channel. Works in Live Mode. Requires Slack Bot Token.',
    category: 'integrations',
    isAdvanced: true,
    defaultConfig: { channel: '#general', text: 'Hello from Kairo!', token: '{{credential.SlackBotToken}}', retry: {}, onErrorWebhook: undefined, simulated_config: { ok: true, ts: new Date().getTime().toString() } },
    configSchema: {
      channel: { label: 'Channel ID or Name', type: 'string', placeholder: '#general or C12345678', required: true },
      text: { label: 'Message Text', type: 'textarea', placeholder: 'New order received: {{input.orderId}}', required: true },
      token: { label: 'Slack Bot Token', type: 'string', placeholder: '{{credential.SlackBotToken}}', helperText: "Use {{credential.SlackBotToken}} for a managed credential.", required: true },
      simulated_config: { label: 'Simulated Output (JSON)', type: 'json', placeholder: '{"ok": true}', helperText: 'Mock response for simulation mode.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'openAiChatCompletion',
    name: 'OpenAI: Chat Completion',
    icon: Bot,
    description: 'Generates a chat completion using OpenAI models. Works in Live Mode.',
    category: 'ai',
    isAdvanced: true,
    defaultConfig: { model: 'gpt-4', messages: '[{"role": "user", "content": "Hello, world!"}]', apiKey: '{{credential.OpenAIKey}}', retry: {}, onErrorWebhook: undefined, simulated_config: { choices: [{ message: { role: 'assistant', content: 'Hello! How can I help you today?' } }] } },
    configSchema: {
      model: { label: 'Model', type: 'string', defaultValue: 'gpt-4', placeholder: 'gpt-4, gpt-3.5-turbo', required: true },
      messages: { label: 'Messages (JSON Array)', type: 'json', placeholder: '[{"role": "user", "content": "{{input.prompt}}"}]', helperText: 'An array of message objects (role and content).', required: true },
      apiKey: { label: 'OpenAI API Key', type: 'string', placeholder: '{{credential.OpenAIKey}}', helperText: "Use {{credential.OpenAIKey}} for a managed credential.", required: true },
      simulated_config: { label: 'Simulated Output (JSON)', type: 'json', placeholder: '{"choices": [{"message": {"content": "..."}}]}', helperText: 'Mock OpenAI response for simulation mode.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'stripeCreatePaymentLink',
    name: 'Stripe: Create Payment Link',
    icon: CreditCard,
    description: 'Creates a Stripe Payment Link (simulated live). Requires Stripe API Key.',
    category: 'integrations',
    isAdvanced: true,
    defaultConfig: { line_items: '[{"price_data": {"currency": "usd", "product_data": {"name": "T-shirt"}, "unit_amount": 2000}, "quantity": 1}]', apiKey: '{{credential.StripeApiKey}}', retry: {}, onErrorWebhook: undefined, simulated_config: { id: 'plink_sim_123', url: 'https://checkout.stripe.com/pay/plink_sim_123' } },
    configSchema: {
      line_items: { label: 'Line Items (JSON Array)', type: 'json', placeholder: '[{"price": "price_123", "quantity": 1}]', helperText: 'Array of line items for the payment link.', required: true },
      apiKey: { label: 'Stripe API Key', type: 'string', placeholder: '{{credential.StripeApiKey}}', helperText: "Use {{credential.StripeApiKey}} for a managed credential. Live mode for this node is simulated but would require the STRIPE_API_KEY environment variable.", required: true },
      simulated_config: { label: 'Simulated Output (JSON)', type: 'json', placeholder: '{"id": "plink_sim_123", "url": "..."}', helperText: 'Mock Stripe response for simulation mode. Live mode is also simulated.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'hubspotCreateContact',
    name: 'HubSpot: Create Contact',
    icon: UserPlus,
    description: 'Creates a new contact in HubSpot (simulated live). Requires HubSpot API Key.',
    category: 'integrations',
    isAdvanced: true,
    defaultConfig: { email: '{{input.email}}', properties: '{"firstname": "{{input.firstName}}", "lastname": "{{input.lastName}}"}', apiKey: '{{credential.HubSpotApiKey}}', retry: {}, onErrorWebhook: undefined, simulated_config: { vid: 12345, "isNew": true } },
    configSchema: {
      email: { label: 'Email', type: 'string', placeholder: '{{trigger.body.email}}', required: true },
      properties: { label: 'Contact Properties (JSON)', type: 'json', placeholder: '{"firstname": "{{trigger.body.fname}}"}', helperText: 'JSON object of HubSpot contact properties.', required: true },
      apiKey: { label: 'HubSpot API Key', type: 'string', placeholder: '{{credential.HubSpotApiKey}}', helperText: "Use {{credential.HubSpotApiKey}} for a managed credential. Live mode for this node is simulated but would require the HUBSPOT_API_KEY environment variable.", required: true },
      simulated_config: { label: 'Simulated Output (JSON)', type: 'json', placeholder: '{"vid": 12345, "isNew": true}', helperText: 'Mock HubSpot response for simulation mode. Live mode is also simulated.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'twilioSendSms',
    name: 'Twilio: Send SMS',
    icon: Smartphone,
    description: 'Sends an SMS message using Twilio (simulated live). Requires Twilio credentials.',
    category: 'integrations',
    isAdvanced: true,
    defaultConfig: { to: '{{input.phone}}', from: '{{env.TWILIO_FROM_NUMBER}}', body: 'Message from Kairo!', accountSid: '{{credential.TwilioAccountSid}}', authToken: '{{credential.TwilioAuthToken}}', retry: {}, onErrorWebhook: undefined, simulated_config: { sid: "SM_sim_12345", status: "queued" } },
    configSchema: {
      to: { label: 'To Phone Number', type: 'string', placeholder: '+15551234567', required: true },
      from: { label: 'From Phone Number (Twilio)', type: 'string', placeholder: '{{env.TWILIO_FROM_NUMBER}}', required: true },
      body: { label: 'Message Body', type: 'textarea', placeholder: 'Hello from your Kairo workflow!', required: true },
      accountSid: { label: 'Twilio Account SID', type: 'string', placeholder: '{{credential.TwilioAccountSid}}', helperText:"Live mode for this node is simulated but would require the TWILIO_ACCOUNT_SID environment variable.", required: true },
      authToken: { label: 'Twilio Auth Token', type: 'string', placeholder: '{{credential.TwilioAuthToken}}', helperText:"Live mode for this node is simulated but would require the TWILIO_AUTH_TOKEN environment variable.", required: true },
      simulated_config: { label: 'Simulated Output (JSON)', type: 'json', placeholder: '{"sid": "SM_sim_123", "status": "queued"}', helperText: 'Mock Twilio response for simulation mode. Live mode is also simulated.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'githubCreateIssue',
    name: 'GitHub: Create Issue',
    icon: Github,
    description: 'Creates an issue in a GitHub repository. Works in Live Mode. Requires GitHub Token.',
    category: 'integrations',
    isAdvanced: true,
    defaultConfig: { owner: '{{env.GITHUB_REPO_OWNER}}', repo: '{{env.GITHUB_REPO_NAME}}', title: 'New issue from Kairo', body: 'Details: {{input.details}}', token: '{{credential.GitHubToken}}', retry: {}, onErrorWebhook: undefined, simulated_config: { number: 99, html_url: "https://github.com/example/repo/issues/99" } },
    configSchema: {
      owner: { label: 'Repository Owner', type: 'string', placeholder: 'e.g., octocat', required: true },
      repo: { label: 'Repository Name', type: 'string', placeholder: 'e.g., Hello-World', required: true },
      title: { label: 'Issue Title', type: 'string', placeholder: 'Bug Report: {{trigger.body.title}}', required: true },
      body: { label: 'Issue Body', type: 'textarea', placeholder: 'Error details: {{trigger.body.error_log}}' },
      token: { label: 'GitHub Token', type: 'string', placeholder: '{{credential.GitHubToken}}', helperText: 'A Personal Access Token with repo scope.', required: true },
      simulated_config: { label: 'Simulated Output (JSON)', type: 'json', placeholder: '{"number": 123, "html_url": "..."}', helperText: 'Mock GitHub response for simulation mode.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'dropboxUploadFile',
    name: 'Dropbox: Upload File',
    icon: UploadCloud,
    description: 'Uploads a file to a Dropbox path (simulated live). Requires Dropbox Token.',
    category: 'integrations',
    isAdvanced: true,
    defaultConfig: { path: '/kairo-uploads/{{input.filename}}', content_placeholder: '{{input.file_content}}', token: '{{credential.DropboxToken}}', retry: {}, onErrorWebhook: undefined, simulated_config: { id: "id:sim_abc123", name: "simulated_file.txt", path_display: "/kairo-uploads/simulated_file.txt" } },
    configSchema: {
      path: { label: 'File Path in Dropbox', type: 'string', placeholder: '/Apps/Kairo/{{trigger.body.filename}}', required: true },
      content_placeholder: { label: 'File Content (Placeholder)', type: 'string', placeholder: '{{api_node.response}}', helperText: 'A placeholder that resolves to the content to be uploaded.', required: true },
      token: { label: 'Dropbox Access Token', type: 'string', placeholder: '{{credential.DropboxToken}}', helperText:"Live mode for this node is simulated but would require the DROPBOX_TOKEN environment variable.", required: true },
      simulated_config: { label: 'Simulated Output (JSON)', type: 'json', placeholder: '{"name": "file.txt", "path_display": "/file.txt"}', helperText: 'Mock Dropbox response for simulation mode. Live mode is also simulated.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'youtubeFetchTrending',
    name: 'YouTube: Fetch Trending',
    icon: TrendingUp,
    description: 'Fetches trending videos from YouTube (simulated live). Requires YOUTUBE_API_KEY env var.',
    category: 'integrations', 
    isAdvanced: true,
    defaultConfig: { region: 'US', maxResults: 3, apiKey: '{{credential.YouTubeApiKey}}', retry: {}, onErrorWebhook: undefined, simulated_config: { videos: [{id: 'sim1', title: 'Simulated Video 1'}, {id: 'sim2', title: 'Simulated Video 2'}] } },
    configSchema: {
      region: { label: 'Region Code', type: 'string', defaultValue: 'US', placeholder: 'US, GB, IN, etc.', required: true },
      maxResults: { label: 'Max Results', type: 'number', defaultValue: 3, placeholder: 'Number of videos', required: true },
      apiKey: { label: 'YouTube API Key', type: 'string', placeholder: '{{credential.YouTubeApiKey}}', helperText:"Use {{credential.YouTubeApiKey}} or {{env.YOUTUBE_API_KEY}}. Live mode for this node is simulated.", required: true},
      simulated_config: { label: 'Simulated Output (JSON for Simulation Mode)', type: 'json', placeholder: '{"videos": [{"id":"vid1", "title":"Mock Video"}]}', helperText: 'Data returned by this node when in simulation mode. Live mode is also simulated.', required: true},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'youtubeDownloadVideo',
    name: 'YouTube: Download Video',
    icon: DownloadCloud,
    description: 'Downloads a YouTube video (simulated live).',
    category: 'integrations',
    isAdvanced: true,
    defaultConfig: { videoUrl: '', quality: 'best', retry: {}, onErrorWebhook: undefined, simulated_config: { filePath: '/simulated/path/to/video.mp4'} },
    configSchema: {
      videoUrl: { label: 'Video URL', type: 'string', placeholder: '{{prev_node.videos[0].url}}', required: true },
      quality: { label: 'Quality', type: 'select', options: ['best', '1080p', '720p', '480p'], defaultValue: 'best', required: true },
      simulated_config: { label: 'Simulated Output (JSON for Simulation Mode)', type: 'json', placeholder: '{"filePath": "/sim/video.mp4"}', helperText: 'Data returned by this node when in simulation mode. Live mode is also simulated.', required: true},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'videoConvertToShorts',
    name: 'Video: Convert to Shorts',
    icon: Scissors,
    description: 'Converts a video to a short format (simulated live).',
    category: 'action',
    isAdvanced: true,
    defaultConfig: { inputFile: '', duration: 60, strategy: 'center_cut', retry: {}, onErrorWebhook: undefined, simulated_config: { shortFilePath: '/simulated/path/to/short.mp4' } },
    configSchema: {
      inputFile: { label: 'Input Video File Path', type: 'string', placeholder: '{{download_node.filePath}}', required: true },
      duration: { label: 'Short Duration (seconds)', type: 'number', defaultValue: 60, required: true },
      strategy: { label: 'Conversion Strategy', type: 'select', options: ['center_cut', 'first_segment', 'ai_highlights'], defaultValue: 'center_cut', required: true},
      simulated_config: { label: 'Simulated Output (JSON for Simulation Mode)', type: 'json', placeholder: '{"shortFilePath": "/sim/short.mp4"}', helperText: 'Data returned by this node when in simulation mode. Live mode is also simulated.', required: true},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'youtubeUploadShort',
    name: 'YouTube: Upload Short',
    icon: UploadCloud,
    description: 'Uploads a video short to YouTube (simulated live). Requires YouTube OAuth credentials.',
    category: 'integrations',
    isAdvanced: true,
    defaultConfig: { filePath: '', title: '', description: '', tags: [], privacy: 'public', credentials: '{{credential.YouTubeOAuth}}', retry: {}, onErrorWebhook: undefined, simulated_config: { uploadStatus: 'success', videoId: 'simulated-short-id'} },
    configSchema: {
      filePath: { label: 'Video File Path', type: 'string', placeholder: '{{convert_node.shortFilePath}}', required: true },
      title: { label: 'Title', type: 'string', placeholder: 'My Awesome Short', required: true },
      description: { label: 'Description', type: 'textarea' },
      tags: { label: 'Tags (comma-separated)', type: 'string', placeholder: 'short, funny, tech' },
      privacy: { label: 'Privacy', type: 'select', options: ['public', 'private', 'unlisted'], defaultValue: 'public', required: true},
      credentials: { label: 'YouTube Credentials/Token', type: 'string', placeholder: '{{credential.YouTubeOAuth}}', helperText: "Use {{credential.YouTubeOAuth}} for managed OAuth. Live mode is simulated.", required: true},
      simulated_config: { label: 'Simulated Output (JSON for Simulation Mode)', type: 'json', placeholder: '{"uploadStatus": "success", "videoId": "sim_yt_id"}', helperText: 'Data returned by this node when in simulation mode. Live mode is also simulated.', required: true},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'workflowNode', 
    name: 'Custom Action', 
    icon: WorkflowIcon,
    description: 'A generic, configurable step in the workflow. Used by AI when a specific node type isn\'t matched. Supports retries and on-error webhook.',
    category: 'action', 
    defaultConfig: { task_description: '', parameters: {}, retry: {}, onErrorWebhook: undefined, simulated_config: {message: "Simulated custom action output"} },
    configSchema: {
      task_description: {label: 'Task Description', type: 'string', placeholder: 'Describe what this node should do', required: true},
      parameters: { label: 'Parameters (JSON)', type: 'textarea', placeholder: '{\n  "custom_param": "value"\n}'},
      simulated_config: { label: 'Simulated Output (JSON for Simulation Mode)', type: 'json', placeholder: '{"result": "mock_custom_result"}', helperText: 'Data returned by this node when in simulation mode, if its logic is not directly executable.'},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  // NEW UTILITY NODES
  {
    type: 'toUpperCase',
    name: 'To Uppercase',
    icon: CaseSensitive,
    description: 'Converts a string to uppercase.',
    category: 'logic',
    defaultConfig: { inputString: '' },
    configSchema: {
      inputString: { label: 'Input String', type: 'string', placeholder: '{{input.text}}', required: true },
    },
    inputHandles: ['input_data'],
    outputHandles: ['output_data', 'status', 'error_message'],
  },
  {
    type: 'toLowerCase',
    name: 'To Lowercase',
    icon: CaseSensitive,
    description: 'Converts a string to lowercase.',
    category: 'logic',
    defaultConfig: { inputString: '' },
    configSchema: {
      inputString: { label: 'Input String', type: 'string', placeholder: '{{input.text}}', required: true },
    },
    inputHandles: ['input_data'],
    outputHandles: ['output_data', 'status', 'error_message'],
  },
  {
    type: 'concatenateStrings',
    name: 'Concatenate Strings',
    icon: Combine,
    description: 'Joins an array of strings into a single string with a separator.',
    category: 'logic',
    defaultConfig: { stringsToConcatenate: '[]', separator: '' },
    configSchema: {
      stringsToConcatenate: { label: 'Strings/Placeholders to Concatenate (JSON array)', type: 'json', placeholder: '["Hello ", "{{input.name}}", "!"]', required: true },
      separator: { label: 'Separator', type: 'string', placeholder: 'e.g., a space or comma', defaultValue: '' },
    },
    inputHandles: ['input_data'],
    outputHandles: ['output_data', 'status', 'error_message'],
  },
  {
    type: 'stringSplit',
    name: 'Split String',
    icon: SplitSquareHorizontal,
    description: 'Splits a string into an array of substrings.',
    category: 'logic',
    defaultConfig: { inputString: '', delimiter: ',' },
    configSchema: {
      inputString: { label: 'Input String', type: 'string', placeholder: '{{input.csv_line}}', required: true },
      delimiter: { label: 'Delimiter', type: 'string', placeholder: 'e.g., , or |', defaultValue: ',', required: true },
    },
    inputHandles: ['input_data'],
    outputHandles: ['output_data', 'status', 'error_message'],
  },
  {
    type: 'formatDate',
    name: 'Format Date',
    icon: CalendarDays,
    description: 'Formats a date string into a custom format.',
    category: 'logic',
    defaultConfig: { inputDateString: '', outputFormatString: 'yyyy-MM-dd HH:mm:ss' },
    configSchema: {
      inputDateString: { label: 'Input Date String/ISO', type: 'string', placeholder: '{{api_node.response.createdAt}}', required: true },
      outputFormatString: { label: 'Output Date Format (date-fns)', type: 'string', defaultValue: 'yyyy-MM-dd HH:mm:ss', placeholder: 'EEEE, MMMM do, yyyy', required: true },
    },
    inputHandles: ['input_data'],
    outputHandles: ['output_data', 'status', 'error_message'],
  },
  {
    type: 'unknown',
    name: 'Unknown Node',
    icon: HelpCircle,
    description: 'Represents an unrecognized or AI-generated node type that needs mapping.',
    category: 'unknown',
    defaultConfig: { error: 'Unknown node type from AI', originalType: '', originalConfig: {} },
    configSchema: {
      originalType: { label: 'Original AI Type', type: 'string' },
      originalConfig: { label: 'Original AI Config (JSON)', type: 'textarea' },
    },
    inputHandles: ['input'],
    outputHandles: ['output'],
  }
];

export const AI_NODE_TYPE_MAPPING: Record<string, string> = {
  // General & Triggers
  'webhooktrigger': 'webhookTrigger',
  'webhook trigger': 'webhookTrigger',
  'http webhook': 'webhookTrigger',
  'incoming webhook': 'webhookTrigger',
  'webhook': 'httpRequest', 
  'http trigger': 'httpRequest', 
  'schedule': 'schedule',
  'cron': 'schedule',
  'cron job': 'schedule',
  'timed trigger': 'schedule',
  'filesystemtrigger': 'fileSystemTrigger',
  'file system trigger': 'fileSystemTrigger',
  'watch folder': 'fileSystemTrigger',
  'on new file': 'fileSystemTrigger',
  'on file create': 'fileSystemTrigger',
  'on file change': 'fileSystemTrigger',
  'file event': 'fileSystemTrigger',
  
  // Actions & I/O
  'httprequest': 'httpRequest',
  'http request': 'httpRequest',
  'api call': 'httpRequest',
  'fetch data': 'httpRequest',
  'get request': 'httpRequest',
  'post request': 'httpRequest',
  'put request': 'httpRequest',
  'delete request': 'httpRequest',
  'patch request': 'httpRequest',
  'sendemail': 'sendEmail',
  'send email': 'sendEmail',
  'email': 'sendEmail',
  'notify by email': 'sendEmail',
  'databasequery': 'databaseQuery',
  'database query': 'databaseQuery',
  'sql query': 'databaseQuery',
  'query database': 'databaseQuery',
  'read database': 'databaseQuery',
  'write database': 'databaseQuery', 
  'logmessage': 'logMessage',
  'log message': 'logMessage',
  'print to console': 'logMessage',
  'debug log': 'logMessage',
  'output message': 'logMessage',
  'log': 'logMessage',
  'getenvvar': 'getEnvironmentVariable',
  'get env var': 'getEnvironmentVariable',
  'get environment variable': 'getEnvironmentVariable',
  'read environment variable': 'getEnvironmentVariable',
  'env var': 'getEnvironmentVariable',

  // Logic & Data
  'parsejson': 'parseJson',
  'parse json': 'parseJson',
  'json transform': 'parseJson',
  'extract from json': 'parseJson',
  'conditionallogic': 'conditionalLogic',
  'conditional': 'conditionalLogic',
  'condition': 'conditionalLogic',
  'if/else': 'conditionalLogic',
  'if condition': 'conditionalLogic',
  'branch': 'conditionalLogic', 
  'filter': 'conditionalLogic', 
  'switch': 'conditionalLogic',
  'route based on condition': 'conditionalLogic',

  // Specific Utility Nodes
  'touppercase': 'toUpperCase',
  'uppercase': 'toUpperCase',
  'tolowercase': 'toLowerCase',
  'lowercase': 'toLowerCase',
  'concatenatestrings': 'concatenateStrings',
  'concatenate': 'concatenateStrings',
  'join strings': 'concatenateStrings',
  'stringsplit': 'stringSplit',
  'split string': 'stringSplit',
  'formatdate': 'formatDate',
  'format date': 'formatDate',
  'date format': 'formatDate',
  'convert date': 'formatDate',
  'arraylength': 'arrayLength',
  'get array length': 'arrayLength',
  'count items in array': 'arrayLength',
  'getitematindex': 'getItemAtIndex',
  'get item from array': 'getItemAtIndex',
  'getobjectproperty': 'getObjectProperty',
  'get property from object': 'getObjectProperty',
  'reducearray': 'reduceArray',
  'reduce array': 'reduceArray',
  'sum array': 'reduceArray',
  'aggregate array': 'reduceArray',
  'average array': 'reduceArray',
  'join list': 'reduceArray',
  'count items': 'reduceArray',
  'parsenumber': 'parseNumber',
  'parse number': 'parseNumber',
  'string to number': 'parseNumber',
  'convert to number': 'parseNumber',

  // AI
  'aitask': 'aiTask',
  'ai task': 'aiTask',
  'llm call': 'aiTask',
  'genai': 'aiTask',
  'generate text': 'aiTask',
  'summarize': 'aiTask', 
  'translate': 'aiTask',
  'analyze sentiment': 'aiTask',
  'classify text': 'aiTask',

  // Grouping / Sub-flows
  'executeflowgroup': 'executeFlowGroup',
  'execute flow group': 'executeFlowGroup',
  'sub workflow': 'executeFlowGroup', 
  'sub-workflow': 'executeFlowGroup',
  'run group': 'executeFlowGroup',
  'encapsulate flow': 'executeFlowGroup',
  'callexternalworkflow': 'callExternalWorkflow',
  'call external workflow': 'callExternalWorkflow',
  'call workflow by id': 'callExternalWorkflow',
  'invoke workflow': 'callExternalWorkflow',
  'run another workflow': 'callExternalWorkflow',

  // Iteration
  'foreach': 'forEach',
  'for each': 'forEach',
  'loop': 'forEach', 
  'iterate': 'forEach',
  'process list': 'forEach',
  'whileloop': 'whileLoop',
  'while loop': 'whileLoop',
  'conditional loop': 'whileLoop',
  'repeat while': 'whileLoop',

  // Control Flow 
  'parallel': 'parallel',
  'concurrent': 'parallel',
  'fork': 'parallel',
  'fan out': 'parallel',
  'run in parallel': 'parallel',
  'delay': 'delay',
  'wait': 'delay',
  'pause': 'delay',
  'sleep': 'delay',

  // Interaction
  'manualinput': 'manualInput',
  'manual input': 'manualInput',
  'user input': 'manualInput',
  'ask user': 'manualInput',
  'human task': 'manualInput',
  'human approval': 'manualInput',
  'get user data': 'manualInput',
  'user decision': 'manualInput',
  'form input': 'manualInput',
  
  // Specific Integrations (New)
  'googlesheetsappendrow': 'googleSheetsAppendRow',
  'google sheets append row': 'googleSheetsAppendRow',
  'add row to google sheet': 'googleSheetsAppendRow',
  'write to google sheets': 'googleSheetsAppendRow',
  'google sheets': 'googleSheetsAppendRow',
  'slackpostmessage': 'slackPostMessage',
  'slack post message': 'slackPostMessage',
  'send slack message': 'slackPostMessage',
  'notify slack': 'slackPostMessage',
  'slack': 'slackPostMessage',
  'openaichatcompletion': 'openAiChatCompletion',
  'openai chat completion': 'openAiChatCompletion',
  'chatgpt': 'openAiChatCompletion',
  'openai': 'openAiChatCompletion',
  'stripecreatepaymentlink': 'stripeCreatePaymentLink',
  'stripe create payment link': 'stripeCreatePaymentLink',
  'create stripe payment': 'stripeCreatePaymentLink',
  'stripe': 'stripeCreatePaymentLink',
  'hubspotcreatecontact': 'hubspotCreateContact',
  'hubspot create contact': 'hubspotCreateContact',
  'create hubspot contact': 'hubspotCreateContact',
  'hubspot': 'hubspotCreateContact',
  'twiliosendsms': 'twilioSendSms',
  'twilio send sms': 'twilioSendSms',
  'send twilio sms': 'twilioSendSms',
  'send sms': 'twilioSendSms',
  'twilio': 'twilioSendSms',
  'githubcreateissue': 'githubCreateIssue',
  'github create issue': 'githubCreateIssue',
  'create github issue': 'githubCreateIssue',
  'github': 'githubCreateIssue',
  'dropboxuploadfile': 'dropboxUploadFile',
  'dropbox upload file': 'dropboxUploadFile',
  'upload to dropbox': 'dropboxUploadFile',
  'dropbox': 'dropboxUploadFile',

  // Google Services (Simulated)
  'googlecalendarlistevents': 'googleCalendarListEvents',
  'list google calendar events': 'googleCalendarListEvents',
  'fetch calendar events': 'googleCalendarListEvents',
  'get calendar events': 'googleCalendarListEvents',
  'google calendar': 'googleCalendarListEvents',


  // YouTube Specific (Conceptual)
  'youtubefetchtrending': 'youtubeFetchTrending',
  'youtube fetch trending': 'youtubeFetchTrending',
  'get trending youtube videos': 'youtubeFetchTrending',
  'fetch youtube videos': 'youtubeFetchTrending',
  'youtubedownloadvideo': 'youtubeDownloadVideo',
  'youtube download': 'youtubeDownloadVideo',
  'download youtube video': 'youtubeDownloadVideo',
  'save youtube video': 'youtubeDownloadVideo',
  'videoconverttoshorts': 'videoConvertToShorts',
  'video convert to shorts': 'videoConvertToShorts',
  'make youtube short': 'videoConvertToShorts',
  'edit video for shorts': 'videoConvertToShorts',
  'create short video': 'videoConvertToShorts',
  'youtubeuploadshort': 'youtubeUploadShort',
  'youtube upload short': 'youtubeUploadShort',
  'post youtube short': 'youtubeUploadShort',
  'upload youtube short': 'youtubeUploadShort',
  'youtube upload': 'youtubeUploadShort', 
  
  // Default/Fallback
  'default': 'workflowNode', 
  'customaction': 'workflowNode',
  'custom action': 'workflowNode',
  'generic step': 'workflowNode',
  'workflowstep': 'workflowNode',
  'action': 'workflowNode',
  'task': 'workflowNode',
  'step': 'workflowNode',
  'workflownode': 'workflowNode', 
  'unknown': 'unknown'
};

export const getDataTransformIcon = (transformType?: string): LucideIcon => {
  switch (transformType) {
    case 'toUpperCase':
    case 'toLowerCase':
      return CaseSensitive;
    case 'stringSplit':
      return SplitSquareHorizontal;
    case 'arrayLength':
      return ListOrdered;
    case 'getItemAtIndex':
      return ListPlus;
    case 'getObjectProperty':
    case 'extractFields':
      return Milestone; 
    case 'concatenateStrings':
      return Combine;
    case 'reduceArray':
    case 'parseNumber': 
      return Sigma;
    case 'formatDate':
      return CalendarDays;
    default:
      return FunctionSquare;
  }
};

export const getCanvasNodeStyling = (category: AvailableNodeType['category']) => {
  switch (category) {
    case 'trigger':
      return {
        headerBg: 'bg-rose-900/50',
        headerIconColor: 'text-rose-300',
        headerTextColor: 'text-rose-200',
        nodeBorder: 'border-rose-800/70',
        inputHandleColor: 'bg-rose-500',
        inputHandleBorder: 'border-rose-400',
        outputHandleColor: 'bg-rose-500',
        outputHandleBorder: 'border-rose-400',
      };
    case 'action':
      return {
        headerBg: 'bg-sky-900/50',
        headerIconColor: 'text-sky-300',
        headerTextColor: 'text-sky-200',
        nodeBorder: 'border-sky-800/70',
        inputHandleColor: 'bg-sky-500',
        inputHandleBorder: 'border-sky-400',
        outputHandleColor: 'bg-sky-500',
        outputHandleBorder: 'border-sky-400',
      };
    case 'integrations':
       return {
        headerBg: 'bg-teal-900/50',
        headerIconColor: 'text-teal-300',
        headerTextColor: 'text-teal-200',
        nodeBorder: 'border-teal-800/70',
        inputHandleColor: 'bg-teal-500',
        inputHandleBorder: 'border-teal-400',
        outputHandleColor: 'bg-teal-500',
        outputHandleBorder: 'border-teal-400',
      };
    case 'io':
      return {
        headerBg: 'bg-slate-700/50',
        headerIconColor: 'text-slate-300',
        headerTextColor: 'text-slate-200',
        nodeBorder: 'border-slate-600/70',
        inputHandleColor: 'bg-slate-500',
        inputHandleBorder: 'border-slate-400',
        outputHandleColor: 'bg-slate-500',
        outputHandleBorder: 'border-slate-400',
      };
    case 'logic':
      return {
        headerBg: 'bg-amber-900/40',
        headerIconColor: 'text-amber-300',
        headerTextColor: 'text-amber-200',
        nodeBorder: 'border-amber-800/60',
        inputHandleColor: 'bg-amber-500',
        inputHandleBorder: 'border-amber-400',
        outputHandleColor: 'bg-amber-500',
        outputHandleBorder: 'border-amber-400',
      };
    case 'ai':
      return {
        headerBg: 'bg-violet-900/50',
        headerIconColor: 'text-violet-300',
        headerTextColor: 'text-violet-200',
        nodeBorder: 'border-violet-800/70',
        inputHandleColor: 'bg-violet-500',
        inputHandleBorder: 'border-violet-400',
        outputHandleColor: 'bg-violet-500',
        outputHandleBorder: 'border-violet-400',
      };
    case 'group':
    case 'iteration':
    case 'control':
    case 'interaction':
        return {
          headerBg: 'bg-emerald-900/50',
          headerIconColor: 'text-emerald-300',
          headerTextColor: 'text-emerald-200',
          nodeBorder: 'border-emerald-800/70',
          inputHandleColor: 'bg-emerald-500',
          inputHandleBorder: 'border-emerald-400',
          outputHandleColor: 'bg-emerald-500',
          outputHandleBorder: 'border-emerald-400',
        };
    default:
      return {
        headerBg: 'bg-gray-700/50',
        headerIconColor: 'text-gray-300',
        headerTextColor: 'text-gray-200',
        nodeBorder: 'border-gray-600/70',
        inputHandleColor: 'bg-gray-500',
        inputHandleBorder: 'border-gray-400',
        outputHandleColor: 'bg-gray-500',
        outputHandleBorder: 'border-gray-400',
      };
  }
};

    