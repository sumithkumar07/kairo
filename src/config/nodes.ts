
import type { AvailableNodeType, RetryConfig, BranchConfig, OnErrorWebhookConfig, ManualInputFieldSchema } from '@/types/workflow';
import { Bot, Braces, FileJson, FunctionSquare, GitBranch, HelpCircle, LogOut, Network, Play, Terminal, Workflow as WorkflowIcon, Database, Mail, Clock, Youtube, TrendingUp, DownloadCloud, Scissors, UploadCloud, Filter, Combine, SplitSquareHorizontal, ListOrdered, Milestone, CaseSensitive, GitFork, Layers, Repeat, RotateCcw, VenetianMask, LucideIcon, UserCheck, Edit3, ClipboardCheck, Sigma, Percent, ListPlus, ListX, Share2, FilePlus2, Timer, CalendarDays, Webhook, KeyRound } from 'lucide-react';

export const NODE_WIDTH = 200; 
export const NODE_HEIGHT = 100; 

const GENERIC_RETRY_CONFIG_SCHEMA = {
  retry: { 
    label: 'Retry Config (JSON, Optional)', 
    type: 'json', 
    placeholder: '{\n  "attempts": 3,\n  "delayMs": 1000,\n  "backoffFactor": 2,\n  "retryOnStatusCodes": [500, 503, 429],\n  "retryOnErrorKeywords": ["timeout", "unavailable"]\n}',
    helperText: 'Define retry strategy: attempts, delayMs, backoffFactor (e.g., 2 for exponential), retryOnStatusCodes (for HTTP nodes), retryOnErrorKeywords (case-insensitive keywords to match in error messages for any node type). All fields optional.',
    defaultValue: {} as RetryConfig
  }
};

const GENERIC_ON_ERROR_WEBHOOK_SCHEMA = {
  onErrorWebhook: {
    label: 'On-Error Webhook (JSON, Optional)',
    type: 'json',
    placeholder: '{\n  "url": "https://my-error-logger.com/log",\n  "method": "POST",\n  "headers": {"X-API-Key": "{{env.ERROR_API_KEY}}"},\n  "bodyTemplate": {\n    "nodeId": "{{failed_node_id}}",\n    "nodeName": "{{failed_node_name}}",\n    "errorMessage": "{{error_message}}",\n    "timestamp": "{{timestamp}}",\n    "workflowSnapshot": "{{workflow_data_snapshot_json}}"\n  }\n}',
    helperText: 'If node fails after all retries, send details to this webhook. Placeholders for body/headers: {{failed_node_id}}, {{failed_node_name}}, {{error_message}}, {{timestamp}}, {{workflow_data_snapshot_json}} (full workflow data as JSON string), and {{env.VAR_NAME}}. This is a fire-and-forget notification. It can be used for simple alerts or to send error details to an endpoint that acts as a Dead-Letter Queue (DLQ) processor or triggers a dedicated error-handling workflow. The `workflow_data_snapshot_json` payload is crucial for DLQ scenarios as it provides the complete context for later analysis or reprocessing.',
    defaultValue: undefined as (OnErrorWebhookConfig | undefined)
  }
};

export const AVAILABLE_NODES_CONFIG: AvailableNodeType[] = [
  {
    type: 'webhookTrigger',
    name: 'Webhook Trigger',
    icon: Webhook,
    description: 'Triggers workflow via HTTP POST to a unique URL. Outputs request data. Base URL: /api/workflow-webhooks/',
    category: 'trigger',
    defaultConfig: { 
      pathSuffix: 'my-hook', 
      securityToken: '',
      simulatedRequestBody: '{"message": "Hello from simulated webhook!"}',
      simulatedRequestHeaders: '{"Content-Type": "application/json", "X-Custom-Header": "SimValue"}',
      simulatedRequestQuery: '{"param1": "test", "param2": "true"}',
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      pathSuffix: { label: 'Path Suffix', type: 'string', placeholder: 'e.g., customer-updates-hook', helperText: "Unique path for this webhook. Full URL: /api/workflow-webhooks/YOUR_SUFFIX", required: true },
      securityToken: { label: 'Security Token (Optional)', type: 'string', placeholder: '{{credential.MyWebhookToken}} or {{env.MY_WEBHOOK_TOKEN}}', helperText: "If set, incoming request must have 'X-Webhook-Token' header with this value." },
      simulatedRequestBody: { label: 'Simulated Request Body (JSON for Simulation)', type: 'json', defaultValue: '{"message": "Hello!"}', helperText: "JSON data for the requestBody output during simulation." },
      simulatedRequestHeaders: { label: 'Simulated Request Headers (JSON for Simulation)', type: 'json', defaultValue: '{}', helperText: "JSON data for the requestHeaders output during simulation." },
      simulatedRequestQuery: { label: 'Simulated Request Query Params (JSON for Simulation)', type: 'json', defaultValue: '{}', helperText: "JSON data for the requestQuery output during simulation." },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: [],
    outputHandles: ['requestBody', 'requestHeaders', 'requestQuery', 'status', 'error_message'],
  },
  {
    type: 'fileSystemTrigger',
    name: 'File System Trigger',
    icon: FilePlus2,
    description: 'Conceptually triggers on file system events (simulated). Supports retries and on-error webhook.',
    category: 'trigger',
    defaultConfig: { 
      directoryPath: '/uploads', 
      eventTypes: '["create", "modify"]', 
      fileNamePattern: '*.csv', 
      pollingIntervalSeconds: 60,
      simulatedFileEvent: '{"eventType": "create", "filePath": "/uploads/new_report.csv", "fileName": "new_report.csv"}',
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      directoryPath: { label: 'Directory Path', type: 'string', placeholder: '/mnt/shared_drive/input_files or {{env.WATCH_FOLDER}}', required: true },
      eventTypes: { label: 'Event Types (JSON Array)', type: 'json', placeholder: '["create", "modify", "delete"]', helperText: 'e.g., create, modify, delete.', required: true },
      fileNamePattern: { label: 'File Name Pattern (Glob, Optional)', type: 'string', placeholder: '*.txt, report-*.csv' },
      pollingIntervalSeconds: { label: 'Polling Interval (seconds, Conceptual)', type: 'number', defaultValue: 60, helperText: 'Conceptual interval for checking for new files.' },
      simulatedFileEvent: { label: 'Simulated File Event (JSON)', type: 'json', placeholder: '{"eventType": "create", "filePath": "/sim/data.txt", "fileName":"data.txt"}', helperText: 'JSON data representing the file event this trigger will output during simulation.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: [],
    outputHandles: ['fileEvent', 'status', 'error_message'],
  },
  {
    type: 'getEnvironmentVariable',
    name: 'Get Environment Variable',
    icon: KeyRound,
    description: 'Retrieves the value of a specified environment variable. Outputs `value` or `null`. Can fail if not set.',
    category: 'io',
    defaultConfig: { variableName: '', failIfNotSet: false, retry: {}, onErrorWebhook: undefined, },
    configSchema: {
      variableName: { label: 'Variable Name', type: 'string', placeholder: 'e.g., MY_API_KEY', required: true, helperText: 'The name of the environment variable to retrieve.' },
      failIfNotSet: { label: 'Fail if Not Set', type: 'boolean', defaultValue: false, helperText: 'If true, the node will error if the environment variable is not found.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['value', 'status', 'error_message'],
  },
  {
    type: 'httpRequest',
    name: 'HTTP Request',
    icon: Network,
    description: 'Makes an HTTP request. Supports retries, on-error webhook, and simulation.',
    category: 'action', 
    defaultConfig: { 
        url: '', 
        method: 'GET', 
        headers: '{\n  "Authorization": "{{credential.MyApiToken}}"\n}', 
        body: '', 
        retry: {}, 
        onErrorWebhook: undefined, 
        simulatedResponse: '{"message": "Simulated HTTP success"}',
        simulatedStatusCode: 200 
    },
    configSchema: {
      url: { label: 'URL', type: 'string', placeholder: 'https://api.example.com/data', required: true },
      method: { 
        label: 'Method', 
        type: 'select', 
        options: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
        defaultValue: 'GET',
        required: true,
      },
      headers: { label: 'Headers (JSON)', type: 'textarea', placeholder: '{\n  "Content-Type": "application/json",\n  "Authorization": "Bearer {{credential.MyApiToken}}"\n}', helperText: "Use {{credential.CRED_NAME}} for secrets." },
      body: { label: 'Body (JSON/Text)', type: 'textarea', placeholder: '{\n  "key": "value"\n}' },
      simulatedResponse: { label: 'Simulated Response Body (JSON/Text for Simulation Mode)', type: 'json', placeholder: '{"data": "mock_value"}', helperText: 'Response body content returned by this node when in simulation mode.'},
      simulatedStatusCode: { label: 'Simulated Status Code (Number for Simulation)', type: 'number', defaultValue: 200, placeholder: '200', helperText: 'Definitive HTTP status code to simulate (e.g., 200, 404, 500). Used to test error handling and retries.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['response', 'status_code', 'status', 'error_message'],
  },
  {
    type: 'schedule',
    name: 'Schedule',
    icon: Clock,
    description: 'Triggers workflow on a defined schedule.',
    category: 'trigger',
    defaultConfig: { cron: '0 * * * *' }, 
    configSchema: {
      cron: { label: 'Cron Expression', type: 'string', defaultValue: '0 * * * *', placeholder: 'e.g., 0 9 * * MON', required: true },
    },
    inputHandles: [],
    outputHandles: ['triggered_at'],
  },
  {
    type: 'sendEmail',
    name: 'Send Email',
    icon: Mail,
    description: 'Sends an email. Supports retries, on-error webhook, and simulation. Configure mail server via EMAIL_ env vars.',
    category: 'action',
    defaultConfig: { to: '', subject: '', body: '', retry: {}, onErrorWebhook: undefined, simulatedMessageId: 'simulated-email-id-123' },
    configSchema: {
      to: { label: 'To', type: 'string', placeholder: 'recipient@example.com or {{input.email}}', required: true },
      subject: { label: 'Subject', type: 'string', placeholder: 'Workflow Notification: {{input.status}}', required: true },
      body: { label: 'Body (HTML or Text)', type: 'textarea', placeholder: 'Details: {{input.details}}', required: true },
      simulatedMessageId: { label: 'Simulated Message ID (String for Simulation Mode)', type: 'string', defaultValue: 'simulated-email-id-123', helperText: 'Message ID returned by this node when in simulation mode.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['messageId', 'status', 'error_message'],
  },
  {
    type: 'databaseQuery',
    name: 'Database Query',
    icon: Database,
    description: 'Executes a SQL query. Supports retries, on-error webhook, and simulation. Use {{credential.DB_CONNECTION_STRING}} or set DB_CONNECTION_STRING env var.',
    category: 'io',
    defaultConfig: { queryText: 'SELECT * FROM my_table WHERE id = $1;', queryParams: '["{{input.id}}"]', retry: {}, onErrorWebhook: undefined, simulatedResults: '[]', simulatedRowCount: 0 },
    configSchema: {
      queryText: { label: 'SQL Query (use $1, $2 for parameters)', type: 'textarea', placeholder: 'SELECT * FROM users WHERE id = $1 AND status = $2;', required: true },
      queryParams: { label: 'Query Parameters (JSON array)', type: 'json', placeholder: '["{{input.userId}}", "active"]', helperText: "Array of values or placeholders for $1, $2, etc." },
      simulatedResults: { label: 'Simulated Results (JSON Array for Simulation Mode)', type: 'json', placeholder: '[{"column1": "mock_data", "column2": 123}]', helperText: 'Results array returned by this node when in simulation mode.' },
      simulatedRowCount: { label: 'Simulated Row Count (Number for Simulation Mode)', type: 'number', defaultValue: 0, helperText: 'Row count returned by this node when in simulation mode. If simulatedResults is provided, this will be its length unless explicitly set.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'], 
    outputHandles: ['results', 'rowCount', 'status', 'error_message'],
  },
  {
    type: 'googleCalendarListEvents',
    name: 'Google Calendar: List Events (Simulated)',
    icon: CalendarDays,
    description: 'Simulates fetching events from Google Calendar. Real execution would require Google OAuth setup. Supports retries and on-error webhook.',
    category: 'action',
    defaultConfig: { 
        maxResults: 10, 
        simulatedResponse: '[{"summary": "Team Sync", "start": {"dateTime": "2024-09-15T10:00:00-07:00"}, "end": {"dateTime": "2024-09-15T11:00:00-07:00"}}, {"summary": "Project Deadline", "start": {"date": "2024-09-20"}, "end": {"date": "2024-09-21"}}]', 
        retry: {}, 
        onErrorWebhook: undefined 
    },
    configSchema: {
      maxResults: { label: 'Max Results (Optional)', type: 'number', defaultValue: 10, placeholder: '10', helperText: 'Maximum number of events to return.' },
      simulatedResponse: { label: 'Simulated Events (JSON Array for Simulation Mode)', type: 'json', placeholder: '[{"summary": "My Event", "start": {"dateTime": "YYYY-MM-DDTHH:mm:ssZ"}}]', helperText: 'Array of event objects this node will output during simulation.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'], 
    outputHandles: ['events', 'status', 'error_message'],
  },
  {
    type: 'parseJson',
    name: 'Parse JSON',
    icon: Braces,
    description: 'Parses a JSON string and extracts data using a path.',
    category: 'logic',
    defaultConfig: { jsonString: '', path: '' },
    configSchema: {
      jsonString: { label: 'JSON Input (e.g. {{prev_node.response}})', type: 'textarea', placeholder: '{{previous_node.response}}', required: true },
      path: { label: 'Extraction Path (e.g. $.data.items[0].name)', type: 'string', placeholder: '$.data.items[0].name' },
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'logMessage',
    name: 'Log Message',
    icon: Terminal,
    description: 'Logs a message to the workflow execution log.',
    category: 'io',
    defaultConfig: { message: 'Workflow log: ' },
    configSchema: {
      message: { label: 'Message to Log', type: 'textarea', placeholder: 'Current value: {{data.value}}', required: true },
    },
    inputHandles: ['input'],
    outputHandles: ['output'],
  },
  {
    type: 'aiTask',
    name: 'AI Task',
    icon: Bot,
    description: 'Performs a task using a GenAI model. Supports retries, on-error webhook, and simulation.',
    category: 'ai',
    defaultConfig: { prompt: '', model: 'googleai/gemini-1.5-flash-latest', retry: {}, onErrorWebhook: undefined, simulatedOutput: 'This is a simulated AI response.' },
    configSchema: {
      prompt: { label: 'Prompt', type: 'textarea', placeholder: 'Summarize the following text: {{input.text}}', required: true },
      model: { label: 'Model ID', type: 'string', defaultValue: 'googleai/gemini-1.5-flash-latest', placeholder: 'e.g., googleai/gemini-1.5-pro-latest', required: true },
      simulatedOutput: { label: 'Simulated AI Output (String for Simulation Mode)', type: 'string', placeholder: 'This is a simulated AI response.', helperText: 'Text output from the AI model when in simulation mode.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'conditionalLogic',
    name: 'Condition',
    icon: Filter,
    description: 'Evaluates a condition. Use its boolean `result` in a subsequent node\'s `_flow_run_condition` config field (e.g. {{this_node_id.result}}) to control execution.',
    category: 'logic',
    defaultConfig: { condition: '' },
    configSchema: {
        condition: { label: 'Condition string (e.g., {{data.value}} == "success", {{data.count}} > 10, {{data.isValid}} === true)', type: 'string', placeholder: '{{data.temperature}} > 30', required: true },
    },
    inputHandles: ['input'],
    outputHandles: ['result'],
  },
  {
    type: 'dataTransform',
    name: 'Transform Data',
    icon: FunctionSquare, 
    description: 'Performs various predefined data transformations. Supports retries and on-error webhook for the overall transformation process.',
    category: 'logic',
    defaultConfig: { 
      transformType: 'toUpperCase', 
      inputString: '', 
      inputObject: '{}', 
      inputArrayPath: '', 
      fieldsToExtract: '[]', 
      stringsToConcatenate: '[]', 
      separator: '',
      delimiter: ',',
      index: 0,
      propertyName: '',
      reducerFunction: 'sum', 
      initialValue: undefined, 
      inputDateString: '',
      outputFormatString: 'yyyy-MM-dd HH:mm:ss',
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
        transformType: { 
          label: 'Transformation Type', 
          type: 'select', 
          options: [
            {value: 'toUpperCase', label: 'To Uppercase'}, 
            {value: 'toLowerCase', label: 'To Lowercase'}, 
            {value: 'extractFields', label: 'Extract Fields from Object'}, 
            {value: 'concatenateStrings', label: 'Concatenate Strings'},
            {value: 'stringSplit', label: 'Split String to Array'},
            {value: 'arrayLength', label: 'Get Array Length'},
            {value: 'getItemAtIndex', label: 'Get Item From Array at Index'},
            {value: 'getObjectProperty', label: 'Get Property From Object'},
            {value: 'reduceArray', label: 'Reduce Array (Sum, Avg, Join, Count)'},
            {value: 'parseNumber', label: 'Parse Number from String'},
            {value: 'formatDate', label: 'Format Date'},
          ],
          defaultValue: 'toUpperCase',
          required: true,
          helperText: "Select the desired data transformation. Specific parameters below will apply based on this selection."
        },
        inputString: { label: 'Input String', type: 'textarea', placeholder: '{{input.text}}', helperText: "Used by: toUpperCase, toLowerCase, stringSplit, parseNumber.", relevantForTypes: ['toUpperCase', 'toLowerCase', 'stringSplit', 'parseNumber'] },
        inputObject: { label: 'Input Object (JSON)', type: 'json', placeholder: '{{input.data_object}}', helperText: "Used by: extractFields, getObjectProperty.", relevantForTypes: ['extractFields', 'getObjectProperty'] },
        inputArrayPath: { label: 'Input Array Path', type: 'string', placeholder: '{{input.list_data}} or {{string_split_node.output_data.array}}', helperText: "Used by: arrayLength, getItemAtIndex, reduceArray. This should be a placeholder resolving to an array.", relevantForTypes: ['arrayLength', 'getItemAtIndex', 'reduceArray'] },
        fieldsToExtract: { label: 'Fields to Extract (JSON array of strings)', type: 'json', placeholder: '["name", "email"]', helperText: "Used by: extractFields. Defines which top-level keys to pick from Input Object.", relevantForTypes: ['extractFields'] },
        stringsToConcatenate: { label: 'Strings/Placeholders to Concatenate (JSON array)', type: 'json', placeholder: '["Hello ", "{{input.name}}", "!"]', helperText: "Used by: concatenateStrings. An array of strings or placeholders that resolve to strings.", relevantForTypes: ['concatenateStrings'] },
        separator: { label: 'Separator', type: 'string', placeholder: '(empty for direct join)', helperText: "Used by: concatenateStrings, reduceArray (with 'join' reducer).", relevantForTypes: ['concatenateStrings', 'reduceArray'] },
        delimiter: { label: 'Delimiter', type: 'string', placeholder: ',', helperText: "Used by: stringSplit.", relevantForTypes: ['stringSplit'] },
        index: { label: 'Index (0-based)', type: 'number', placeholder: '0', helperText: "Used by: getItemAtIndex.", relevantForTypes: ['getItemAtIndex'] },
        propertyName: { label: 'Property Name', type: 'string', placeholder: 'user.address.city', helperText: "Used by: getObjectProperty.", relevantForTypes: ['getObjectProperty'] },
        reducerFunction: {
          label: 'Reducer Function',
          type: 'select',
          options: [
            { value: 'sum', label: 'Sum (numbers)' },
            { value: 'average', label: 'Average (numbers)' },
            { value: 'join', label: 'Join (strings)' },
            { value: 'countOccurrences', label: 'Count Occurrences (any type)' },
          ],
          defaultValue: 'sum',
          helperText: "Used by: reduceArray. Defines the reduction operation.",
          relevantForTypes: ['reduceArray'],
        },
        initialValue: { label: 'Initial Value (Optional)', type: 'string', placeholder: 'e.g., 0 for sum, "" for join', helperText: 'Used by: reduceArray. Starting value for reduction. Type should match array elements or expected output (e.g., "0" for sum, "{}" for count). Can be a placeholder.', relevantForTypes: ['reduceArray'] },
        inputDateString: { label: 'Input Date String/ISO', type: 'string', placeholder: '{{api_node.response.createdAt}} or 2023-10-26T10:30:00Z', helperText: "Used by: formatDate. The date value to format.", relevantForTypes: ['formatDate'] },
        outputFormatString: { label: 'Output Date Format', type: 'string', defaultValue: 'yyyy-MM-dd HH:mm:ss', placeholder: 'yyyy-MM-dd HH:mm:ss', helperText: "Used by: formatDate. Desired date output format (date-fns).", relevantForTypes: ['formatDate'] },
        ...GENERIC_RETRY_CONFIG_SCHEMA,
        ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input_data'], 
    outputHandles: ['output_data', 'status', 'error_message'], 
  },
  {
    type: 'executeFlowGroup',
    name: 'Execute Flow Group',
    icon: Layers, 
    description: 'Executes an encapsulated group of nodes as a sub-flow. Supports retries and on-error webhook for the entire group execution.',
    category: 'group',
    isAdvanced: true,
    defaultConfig: {
      flowGroupNodes: '[]', 
      flowGroupConnections: '[]', 
      inputMapping: '{}', 
      outputMapping: '{}',
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      flowGroupNodes: { label: 'Flow Group Nodes (JSON Array of Node definitions)', type: 'json', placeholder: '[{\n  "id":"sub_node_1", \n  "type":"logMessage", \n  "name":"Log in Group", \n  "position":{"x":10,"y":10},\n  "config":{"message":"Message from sub-flow {{inputMapping.dataFromParent}}"}\n}]', helperText: 'Define the nodes for this group.', required: true },
      flowGroupConnections: { label: 'Flow Group Connections (JSON Array of Connection definitions)', type: 'json', placeholder: '[{\n  "sourceNodeId":"sub_node_1", \n  "targetNodeId":"sub_node_2", \n  "sourceHandle":"output"\n}]', helperText: 'Define connections between nodes in this group.' },
      inputMapping: { label: 'Input Mapping (JSON Object)', type: 'json', placeholder: '{\n  "internalInputName": "{{parentWorkflow.someNode.output}}",\n  "dataFromParent": "{{trigger.some_data}}"\n}', helperText: 'Map parent data to group inputs. Access mapped inputs inside group nodes using their "internalInputName".' },
      outputMapping: { label: 'Output Mapping (JSON Object)', type: 'json', placeholder: '{\n  "parentOutputName": "{{group_node_id.result}}"\n}', helperText: 'Map group results to parent outputs. This node will output these mapped values.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'], 
    outputHandles: ['output', 'status', 'error_message'], 
  },
  {
    type: 'forEach',
    name: 'For Each Loop',
    icon: Repeat,
    description: 'Iterates over an array and executes a sub-flow for each item. Supports "continue on error", retries for the whole loop, and on-error webhook if the loop fails.',
    category: 'iteration',
    defaultConfig: {
      inputArrayPath: '',
      iterationNodes: '[]',
      iterationConnections: '[]',
      iterationResultSource: '', 
      continueOnError: false,
      retry: {}, 
      onErrorWebhook: undefined,
    },
    configSchema: {
      inputArrayPath: { label: 'Input Array Path', type: 'string', placeholder: '{{api_node.response.users}}', helperText: 'Placeholder for the array to iterate over.', required: true },
      iterationNodes: { label: 'Iteration Nodes (JSON Array of Node definitions)', type: 'json', placeholder: '[{\n  "id":"loop_log", \n  "type":"logMessage", \n  "name":"Log Item", \n  "position":{"x":10,"y":10},\n  "config":{"message":"Processing item: {{item.name}}"}\n}]', helperText: 'Nodes to execute for each item. Use {{item.property}} to access current item data.', required: true },
      iterationConnections: { label: 'Iteration Connections (JSON Array of Connection definitions)', type: 'json', placeholder: '[]', helperText: 'Connections between nodes within the iteration sub-flow.' },
      iterationResultSource: { label: 'Iteration Result Source (Optional Placeholder)', type: 'string', placeholder: '{{last_node_in_subflow.output}}', helperText: 'Placeholder to extract a specific value from each iteration\'s data. If omitted, the entire output of the last executed node in each sub-flow iteration is collected.' },
      continueOnError: { label: 'Continue On Error', type: 'boolean', defaultValue: false, helperText: 'If true, loop continues if an iteration errors; results will show individual statuses.'},
      ...GENERIC_RETRY_CONFIG_SCHEMA, 
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input_array_data'], 
    outputHandles: ['results', 'status', 'error_message'], 
  },
  {
    type: 'whileLoop',
    name: 'While Loop',
    icon: RotateCcw, 
    description: 'Executes a sub-flow repeatedly as long as a condition is true. Condition is evaluated before each iteration. Supports retries for the whole loop and on-error webhook if the loop fails.',
    category: 'iteration',
    defaultConfig: {
      condition: '',
      loopNodes: '[]',
      loopConnections: '[]',
      maxIterations: 100, 
      retry: {}, 
      onErrorWebhook: undefined,
    },
    configSchema: {
      condition: { label: 'Loop Condition (evaluates to boolean)', type: 'string', placeholder: '{{data.status}} === "pending" || {{counter.value}} < 10', helperText: 'The loop continues as long as this condition is true. Evaluated before each iteration.', required: true },
      loopNodes: { label: 'Loop Nodes (JSON Array of Node definitions)', type: 'json', placeholder: '[{\n  "id":"loop_action", \n  "type":"httpRequest", \n  ...\n}]', helperText: 'Nodes to execute in each iteration. These nodes should eventually affect the loop condition.', required: true },
      loopConnections: { label: 'Loop Connections (JSON Array of Connection definitions)', type: 'json', placeholder: '[]', helperText: 'Connections between nodes within the loop sub-flow.' },
      maxIterations: { label: 'Max Iterations (Optional, Default 100)', type: 'number', defaultValue: 100, placeholder: '100', helperText: 'Safety limit to prevent infinite loops.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input_data'], 
    outputHandles: ['iterations_completed', 'status', 'error_message'],
  },
  {
    type: 'parallel',
    name: 'Parallel Execution',
    icon: GitFork, 
    description: 'Executes multiple branches of nodes concurrently, optionally limiting concurrency. Collects results from all branches. Supports retries for the whole block and on-error webhook if it fails.',
    category: 'control', 
    isAdvanced: true,
    defaultConfig: {
      branches: '[]',
      concurrencyLimit: 0,
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      branches: { 
        label: 'Branches (JSON Array of Branch definitions)', 
        type: 'json', 
        placeholder: '[{\n  "id": "branch_1",\n  "name": "Image Processing",\n  "nodes": [{"id":"img_op_1", "type":"aiTask", ...}],\n  "connections": [],\n  "inputMapping": {"img_data": "{{parent.image_url}}"},\n  "outputSource": "{{img_op_1.processed_image_url}}"\n}]',
        helperText: 'Define branches to run in parallel. Each branch has id, nodes, connections, optional inputMapping, and optional outputSource.',
        required: true,
      },
      concurrencyLimit: {
        label: 'Concurrency Limit (Optional)',
        type: 'number',
        defaultValue: 0,
        placeholder: 'e.g., 3 (0 or less means no limit)',
        helperText: 'Max number of branches to run at once. 0 or less means unlimited concurrency.'
      },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'], 
    outputHandles: ['results', 'status', 'error_message'], 
  },
  {
    type: 'manualInput',
    name: 'Manual Input (Simulated)',
    icon: UserCheck,
    description: 'Simulates a step requiring human input. Outputs pre-configured data. Supports retries and on-error webhook.',
    category: 'interaction',
    defaultConfig: {
      instructions: 'Please review and provide input.',
      inputFieldsSchema: '[{"id": "approval", "label": "Approve?", "type": "boolean", "defaultValue": true}]',
      simulatedResponse: '{"approval": true, "notes": "Simulated approval"}',
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      instructions: { label: 'User Instructions', type: 'textarea', placeholder: 'Describe what the user needs to do.', required: true },
      inputFieldsSchema: { label: 'Input Fields Schema (JSON Array)', type: 'json', placeholder: '[{"id":"field_id","label":"Field Label","type":"text"}]', helperText: 'Define the form fields for user input (id, label, type: text/textarea/number/boolean/select, options[] for select).', required: true },
      simulatedResponse: { label: 'Simulated Response (JSON)', type: 'json', placeholder: '{"field_id":"simulated_value"}', helperText: 'Data this node will output during simulation. This JSON object, when parsed, becomes the value available on the node\'s \'output\' handle and should be consistent with the structure defined by inputFieldsSchema.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'callExternalWorkflow',
    name: 'Call External Workflow',
    icon: Share2, 
    description: 'Calls another workflow by its ID (currently simulated). Define input/output mappings and simulated output. Supports retries and on-error webhook.',
    category: 'group',
    defaultConfig: {
      calledWorkflowId: '',
      inputMapping: '{}',
      outputMapping: '{}',
      simulatedOutput: '{"simulatedResult": "data from called workflow"}',
      retry: {},
      onErrorWebhook: undefined,
    },
    configSchema: {
      calledWorkflowId: { label: 'Called Workflow ID', type: 'string', placeholder: 'e.g., "customer_onboarding_flow_v2"', required: true },
      inputMapping: { label: 'Input Mapping (JSON)', type: 'json', placeholder: '{\n  "targetWorkflowInputName": "{{currentWorkflow.someNode.output}}"\n}', helperText: 'Map data from this workflow to the inputs of the called workflow.' },
      outputMapping: { label: 'Output Mapping (JSON)', type: 'json', placeholder: '{\n  "currentWorkflowOutputName": "{{calledWorkflow.result}}"\n}', helperText: 'Map outputs from the called workflow (from its simulatedOutput, via {{calledWorkflow.property}} placeholders) back to this node\'s output handle.' },
      simulatedOutput: { label: 'Simulated Output (JSON for called workflow)', type: 'json', placeholder: '{\n  "result": "mock data", "details": {"status":"ok"}\n}', helperText: 'Data this node will output to simulate the called workflow\'s execution. Structure this as if it were the entire output object of the called workflow. This JSON object is the direct data source that `outputMapping` placeholders (like `{{calledWorkflow.some_key}}`) will reference.', required: true },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'delay',
    name: 'Delay',
    icon: Timer,
    description: 'Pauses workflow execution for a specified duration in milliseconds.',
    category: 'control',
    defaultConfig: { delayMs: 1000, retry: {}, onErrorWebhook: undefined, },
    configSchema: {
      delayMs: { label: 'Delay (milliseconds)', type: 'number', defaultValue: 1000, required: true, placeholder: 'e.g., 5000 for 5 seconds', helperText: 'The duration for which the workflow will pause.' },
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'youtubeFetchTrending',
    name: 'YouTube: Fetch Trending',
    icon: TrendingUp,
    description: 'Fetches trending videos from YouTube (conceptual - currently logs intent). Requires YOUTUBE_API_KEY env var. Supports retries and on-error webhook.',
    category: 'action', 
    defaultConfig: { region: 'US', maxResults: 3, apiKey: '{{credential.YouTubeApiKey}}', retry: {}, onErrorWebhook: undefined, simulated_config: { videos: [{id: 'sim1', title: 'Simulated Video 1'}, {id: 'sim2', title: 'Simulated Video 2'}] } },
    configSchema: {
      region: { label: 'Region Code', type: 'string', defaultValue: 'US', placeholder: 'US, GB, IN, etc.', required: true },
      maxResults: { label: 'Max Results', type: 'number', defaultValue: 3, placeholder: 'Number of videos', required: true },
      apiKey: { label: 'YouTube API Key', type: 'string', placeholder: '{{credential.YouTubeApiKey}}', helperText:"Use {{credential.YouTubeApiKey}} or {{env.YOUTUBE_API_KEY}}.", required: true},
      simulated_config: { label: 'Simulated Output (JSON for Simulation Mode)', type: 'json', placeholder: '{"videos": [{"id":"vid1", "title":"Mock Video"}]}', helperText: 'Data returned by this node when in simulation mode.', required: true},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['videos', 'status', 'error_message'],
  },
  {
    type: 'youtubeDownloadVideo',
    name: 'YouTube: Download Video',
    icon: DownloadCloud,
    description: 'Downloads a YouTube video (conceptual - currently logs intent). Supports retries and on-error webhook.',
    category: 'action',
    defaultConfig: { videoUrl: '', quality: 'best', retry: {}, onErrorWebhook: undefined, simulated_config: { filePath: '/simulated/path/to/video.mp4'} },
    configSchema: {
      videoUrl: { label: 'Video URL', type: 'string', placeholder: '{{prev_node.videos[0].url}}', required: true },
      quality: { label: 'Quality', type: 'select', options: ['best', '1080p', '720p', '480p'], defaultValue: 'best', required: true },
      simulated_config: { label: 'Simulated Output (JSON for Simulation Mode)', type: 'json', placeholder: '{"filePath": "/sim/video.mp4"}', helperText: 'Data returned by this node when in simulation mode.', required: true},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['filePath', 'status', 'error_message'],
  },
  {
    type: 'videoConvertToShorts',
    name: 'Video: Convert to Shorts',
    icon: Scissors,
    description: 'Converts a video to a short format (conceptual - currently logs intent). Supports retries and on-error webhook.',
    category: 'action',
    defaultConfig: { inputFile: '', duration: 60, strategy: 'center_cut', retry: {}, onErrorWebhook: undefined, simulated_config: { shortFilePath: '/simulated/path/to/short.mp4' } },
    configSchema: {
      inputFile: { label: 'Input Video File Path', type: 'string', placeholder: '{{download_node.filePath}}', required: true },
      duration: { label: 'Short Duration (seconds)', type: 'number', defaultValue: 60, required: true },
      strategy: { label: 'Conversion Strategy', type: 'select', options: ['center_cut', 'first_segment', 'ai_highlights'], defaultValue: 'center_cut', required: true},
      simulated_config: { label: 'Simulated Output (JSON for Simulation Mode)', type: 'json', placeholder: '{"shortFilePath": "/sim/short.mp4"}', helperText: 'Data returned by this node when in simulation mode.', required: true},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['shortFilePath', 'status', 'error_message'],
  },
  {
    type: 'youtubeUploadShort',
    name: 'YouTube: Upload Short',
    icon: UploadCloud,
    description: 'Uploads a video short to YouTube (conceptual - currently logs intent). Requires YouTube OAuth credentials. Supports retries and on-error webhook.',
    category: 'action',
    defaultConfig: { filePath: '', title: '', description: '', tags: [], privacy: 'public', credentials: '{{credential.YouTubeOAuth}}', retry: {}, onErrorWebhook: undefined, simulated_config: { uploadStatus: 'success', videoId: 'simulated-short-id'} },
    configSchema: {
      filePath: { label: 'Video File Path', type: 'string', placeholder: '{{convert_node.shortFilePath}}', required: true },
      title: { label: 'Title', type: 'string', placeholder: 'My Awesome Short', required: true },
      description: { label: 'Description', type: 'textarea' },
      tags: { label: 'Tags (comma-separated)', type: 'string', placeholder: 'short, funny, tech' },
      privacy: { label: 'Privacy', type: 'select', options: ['public', 'private', 'unlisted'], defaultValue: 'public', required: true},
      credentials: { label: 'YouTube Credentials/Token', type: 'string', placeholder: '{{credential.YouTubeOAuth}}', helperText: "Use {{credential.YouTubeOAuth}} for managed OAuth.", required: true},
      simulated_config: { label: 'Simulated Output (JSON for Simulation Mode)', type: 'json', placeholder: '{"uploadStatus": "success", "videoId": "sim_yt_id"}', helperText: 'Data returned by this node when in simulation mode.', required: true},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['uploadStatus', 'videoId', 'status', 'error_message'],
  },
  {
    type: 'workflowNode', 
    name: 'Custom Action', 
    icon: WorkflowIcon,
    description: 'A generic, configurable step in the workflow. Used by AI when a specific node type isn\'t matched. Supports retries and on-error webhook.',
    category: 'action', 
    defaultConfig: { task_description: '', parameters: {}, retry: {}, onErrorWebhook: undefined, simulated_config: {message: "Simulated custom action output"} },
    configSchema: {
      task_description: {label: 'Task Description', type: 'string', placeholder: 'Describe what this node should do', required: true},
      parameters: { label: 'Parameters (JSON)', type: 'textarea', placeholder: '{\n  "custom_param": "value"\n}'},
      simulated_config: { label: 'Simulated Output (JSON for Simulation Mode)', type: 'json', placeholder: '{"result": "mock_custom_result"}', helperText: 'Data returned by this node when in simulation mode, if its logic is not directly executable.'},
      ...GENERIC_RETRY_CONFIG_SCHEMA,
      ...GENERIC_ON_ERROR_WEBHOOK_SCHEMA,
    },
    inputHandles: ['input'],
    outputHandles: ['output', 'status', 'error_message'],
  },
  {
    type: 'unknown',
    name: 'Unknown Node',
    icon: HelpCircle,
    description: 'Represents an unrecognized or AI-generated node type that needs mapping.',
    category: 'unknown',
    defaultConfig: { error: 'Unknown node type from AI', originalType: '', originalConfig: {} },
    configSchema: {
      originalType: { label: 'Original AI Type', type: 'string' },
      originalConfig: { label: 'Original AI Config (JSON)', type: 'textarea' },
    },
    inputHandles: ['input'],
    outputHandles: ['output'],
  }
];

export const AI_NODE_TYPE_MAPPING: Record<string, string> = {
  // General & Triggers
  'webhooktrigger': 'webhookTrigger',
  'webhook trigger': 'webhookTrigger',
  'http webhook': 'webhookTrigger',
  'incoming webhook': 'webhookTrigger',
  'webhook': 'httpRequest', 
  'http trigger': 'httpRequest', 
  'schedule': 'schedule',
  'cron': 'schedule',
  'cron job': 'schedule',
  'timed trigger': 'schedule',
  'filesystemtrigger': 'fileSystemTrigger',
  'file system trigger': 'fileSystemTrigger',
  'watch folder': 'fileSystemTrigger',
  'on new file': 'fileSystemTrigger',
  'on file create': 'fileSystemTrigger',
  'on file change': 'fileSystemTrigger',
  'file event': 'fileSystemTrigger',
  
  // Actions & I/O
  'httprequest': 'httpRequest',
  'http request': 'httpRequest',
  'api call': 'httpRequest',
  'fetch data': 'httpRequest',
  'get request': 'httpRequest',
  'post request': 'httpRequest',
  'put request': 'httpRequest',
  'delete request': 'httpRequest',
  'patch request': 'httpRequest',
  'sendemail': 'sendEmail',
  'send email': 'sendEmail',
  'email': 'sendEmail',
  'notify by email': 'sendEmail',
  'databasequery': 'databaseQuery',
  'database query': 'databaseQuery',
  'sql query': 'databaseQuery',
  'query database': 'databaseQuery',
  'read database': 'databaseQuery',
  'write database': 'databaseQuery', 
  'logmessage': 'logMessage',
  'log message': 'logMessage',
  'print to console': 'logMessage',
  'debug log': 'logMessage',
  'output message': 'logMessage',
  'getenvvar': 'getEnvironmentVariable',
  'get env var': 'getEnvironmentVariable',
  'get environment variable': 'getEnvironmentVariable',
  'read environment variable': 'getEnvironmentVariable',
  'env var': 'getEnvironmentVariable',

  // Logic & Data
  'parsejson': 'parseJson',
  'parse json': 'parseJson',
  'json transform': 'parseJson',
  'extract from json': 'parseJson',
  'conditionallogic': 'conditionalLogic',
  'conditional': 'conditionalLogic',
  'condition': 'conditionalLogic',
  'if/else': 'conditionalLogic',
  'if condition': 'conditionalLogic',
  'branch': 'conditionalLogic', 
  'filter': 'conditionalLogic', 
  'switch': 'conditionalLogic',
  'route based on condition': 'conditionalLogic',
  'datatransform': 'dataTransform',
  'transform data': 'dataTransform',
  'manipulate data': 'dataTransform',
  'map data': 'dataTransform',
  'script': 'dataTransform', 
  'custom script': 'dataTransform',
  'run code': 'dataTransform',
  'javascript': 'dataTransform',
  'code': 'dataTransform',
  'uppercase': 'dataTransform', 
  'touppercase': 'dataTransform',
  'lowercase': 'dataTransform',
  'tolowercase': 'dataTransform',
  'extractfields': 'dataTransform',
  'concatenate': 'dataTransform',
  'concatenatestrings': 'dataTransform',
  'stringsplit': 'dataTransform',
  'split string': 'dataTransform',
  'arraylength': 'dataTransform',
  'get array length': 'dataTransform',
  'count items in array': 'dataTransform',
  'getitematindex': 'dataTransform',
  'get item from array': 'dataTransform',
  'getobjectproperty': 'dataTransform',
  'get property from object': 'dataTransform',
  'reducearray': 'dataTransform',
  'reduce array': 'dataTransform',
  'sum array': 'dataTransform',
  'aggregate array': 'dataTransform',
  'average array': 'dataTransform',
  'join list': 'dataTransform',
  'count items': 'dataTransform',
  'parsenumber': 'dataTransform',
  'parse number': 'dataTransform',
  'string to number': 'dataTransform',
  'convert to number': 'dataTransform',
  'formatdate': 'dataTransform',
  'format date': 'dataTransform',
  'date format': 'dataTransform',
  'convert date': 'dataTransform',

  // AI
  'aitask': 'aiTask',
  'ai task': 'aiTask',
  'llm call': 'aiTask',
  'genai': 'aiTask',
  'generate text': 'aiTask',
  'summarize': 'aiTask', 
  'translate': 'aiTask',
  'analyze sentiment': 'aiTask',
  'classify text': 'aiTask',

  // Grouping / Sub-flows
  'executeflowgroup': 'executeFlowGroup',
  'execute flow group': 'executeFlowGroup',
  'sub workflow': 'executeFlowGroup', 
  'sub-workflow': 'executeFlowGroup',
  'run group': 'executeFlowGroup',
  'encapsulate flow': 'executeFlowGroup',
  'callexternalworkflow': 'callExternalWorkflow',
  'call external workflow': 'callExternalWorkflow',
  'call workflow by id': 'callExternalWorkflow',
  'invoke workflow': 'callExternalWorkflow',
  'run another workflow': 'callExternalWorkflow',

  // Iteration
  'foreach': 'forEach',
  'for each': 'forEach',
  'loop': 'forEach', 
  'iterate': 'forEach',
  'process list': 'forEach',
  'whileloop': 'whileLoop',
  'while loop': 'whileLoop',
  'conditional loop': 'whileLoop',
  'repeat while': 'whileLoop',

  // Control Flow 
  'parallel': 'parallel',
  'concurrent': 'parallel',
  'fork': 'parallel',
  'fan out': 'parallel',
  'run in parallel': 'parallel',
  'delay': 'delay',
  'wait': 'delay',
  'pause': 'delay',
  'sleep': 'delay',

  // Interaction
  'manualinput': 'manualInput',
  'manual input': 'manualInput',
  'user input': 'manualInput',
  'ask user': 'manualInput',
  'human task': 'manualInput',
  'human approval': 'manualInput',
  'get user data': 'manualInput',
  'user decision': 'manualInput',
  'form input': 'manualInput',
  
  // Google Services (Simulated)
  'googlecalendarlistevents': 'googleCalendarListEvents',
  'list google calendar events': 'googleCalendarListEvents',
  'fetch calendar events': 'googleCalendarListEvents',
  'get calendar events': 'googleCalendarListEvents',
  'google calendar': 'googleCalendarListEvents',


  // YouTube Specific (Conceptual)
  'youtubefetchtrending': 'youtubeFetchTrending',
  'youtube fetch trending': 'youtubeFetchTrending',
  'get trending youtube videos': 'youtubeFetchTrending',
  'fetch youtube videos': 'youtubeFetchTrending',
  'youtubedownloadvideo': 'youtubeDownloadVideo',
  'youtube download': 'youtubeDownloadVideo',
  'download youtube video': 'youtubeDownloadVideo',
  'save youtube video': 'youtubeDownloadVideo',
  'videoconverttoshorts': 'videoConvertToShorts',
  'video convert to shorts': 'videoConvertToShorts',
  'make youtube short': 'videoConvertToShorts',
  'edit video for shorts': 'videoConvertToShorts',
  'create short video': 'videoConvertToShorts',
  'youtubeuploadshort': 'youtubeUploadShort',
  'youtube upload short': 'youtubeUploadShort',
  'post youtube short': 'youtubeUploadShort',
  'upload youtube short': 'youtubeUploadShort',
  'youtube upload': 'youtubeUploadShort', 
  
  // Default/Fallback
  'default': 'workflowNode', 
  'customaction': 'workflowNode',
  'custom action': 'workflowNode',
  'generic step': 'workflowNode',
  'workflowstep': 'workflowNode',
  'action': 'workflowNode',
  'task': 'workflowNode',
  'step': 'workflowNode',
  'workflownode': 'workflowNode', 
  'unknown': 'unknown'
};

export const getDataTransformIcon = (transformType?: string): LucideIcon => {
  switch (transformType) {
    case 'toUpperCase':
    case 'toLowerCase':
      return CaseSensitive;
    case 'stringSplit':
      return SplitSquareHorizontal;
    case 'arrayLength':
      return ListOrdered;
    case 'getItemAtIndex':
      return ListPlus;
    case 'getObjectProperty':
    case 'extractFields':
      return Milestone; 
    case 'concatenateStrings':
      return Combine;
    case 'reduceArray':
    case 'parseNumber': 
      return Sigma;
    case 'formatDate':
      return CalendarDays;
    default:
      return FunctionSquare;
  }
};

export const getCanvasNodeStyling = (category: AvailableNodeType['category']) => {
  switch (category) {
    case 'trigger':
      return {
        headerBg: 'bg-indigo-500',
        headerIconColor: 'text-indigo-100',
        headerTextColor: 'text-white',
        nodeBorder: 'border-indigo-600',
        inputHandleColor: 'bg-indigo-400',
        inputHandleBorder: 'border-indigo-300',
        outputHandleColor: 'bg-indigo-400',
        outputHandleBorder: 'border-indigo-300',
      };
    case 'action':
      return {
        headerBg: 'bg-sky-500',
        headerIconColor: 'text-sky-100',
        headerTextColor: 'text-white',
        nodeBorder: 'border-sky-600',
        inputHandleColor: 'bg-sky-400',
        inputHandleBorder: 'border-sky-300',
        outputHandleColor: 'bg-sky-400',
        outputHandleBorder: 'border-sky-300',
      };
    case 'io': // For nodes like Database, Log
      return {
        headerBg: 'bg-slate-500',
        headerIconColor: 'text-slate-100',
        headerTextColor: 'text-white',
        nodeBorder: 'border-slate-600',
        inputHandleColor: 'bg-slate-400',
        inputHandleBorder: 'border-slate-300',
        outputHandleColor: 'bg-slate-400',
        outputHandleBorder: 'border-slate-300',
      };
    case 'logic':
      return {
        headerBg: 'bg-amber-500',
        headerIconColor: 'text-amber-100',
        headerTextColor: 'text-white',
        nodeBorder: 'border-amber-600',
        inputHandleColor: 'bg-amber-400',
        inputHandleBorder: 'border-amber-300',
        outputHandleColor: 'bg-amber-400',
        outputHandleBorder: 'border-amber-300',
      };
    case 'ai':
      return {
        headerBg: 'bg-violet-500',
        headerIconColor: 'text-violet-100',
        headerTextColor: 'text-white',
        nodeBorder: 'border-violet-600',
        inputHandleColor: 'bg-violet-400',
        inputHandleBorder: 'border-violet-300',
        outputHandleColor: 'bg-violet-400',
        outputHandleBorder: 'border-violet-300',
      };
    case 'group':
    case 'iteration':
    case 'control':
    case 'interaction':
        return {
          headerBg: 'bg-emerald-500',
          headerIconColor: 'text-emerald-100',
          headerTextColor: 'text-white',
          nodeBorder: 'border-emerald-600',
          inputHandleColor: 'bg-emerald-400',
          inputHandleBorder: 'border-emerald-300',
          outputHandleColor: 'bg-emerald-400',
          outputHandleBorder: 'border-emerald-300',
        };
    default: // unknown and any other
      return {
        headerBg: 'bg-gray-400',
        headerIconColor: 'text-gray-800',
        headerTextColor: 'text-gray-900',
        nodeBorder: 'border-gray-500',
        inputHandleColor: 'bg-gray-300',
        inputHandleBorder: 'border-gray-200',
        outputHandleColor: 'bg-gray-300',
        outputHandleBorder: 'border-gray-200',
      };
  }
};
